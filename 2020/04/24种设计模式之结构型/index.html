<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>
24种设计模式之结构型 
</title>

    
  <link href="https://sltaurusblog.gitee.io/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />



  
  <meta name="author" content="SLTaurus" />
  <meta name="description" content="SLTaurus的博客" />



<meta name="generator" content="Hugo 0.57.2" />

<link rel="canonical" href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" />


<meta property="og:title" content="24种设计模式之结构型 " />
<meta property="og:description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" />
<meta property="article:published_time" content="2020-04-21T22:36:33+08:00" />
<meta property="article:modified_time" content="2020-04-21T22:36:33+08:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="24种设计模式之结构型 "/>
<meta name="twitter:description" content="24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。"/>


<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/github-markdown.css" />
<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/semantic.min.css" />
<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/site.css" />


  
    <link rel="stylesheet"  href="https://sltaurusblog.gitee.io/css/prism.css">
  



<style>
  a {
    color: seagreen !important;
  }
</style>



<style>
  .inverted a {
     color: darkseagreen !important;
  }
</style>


  </head>

  
  <body style="background: black;">
  
    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          
<nav class="ui secondary inverted menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/sltaurusblog.gitee.io'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          
<div class="ui centered relaxed grid dream-grid">
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single">

    <section class="ui top attached segment" id="dream-save-post-as-img">
      <header style="margin-top: 0 !important;">
        <h2 class="ui header">
          24种设计模式之结构型 
          <div class="sub header">@ SLTaurus · Tuesday, Apr 21, 2020 · 20 分钟阅读 · 更新于 Apr 21, 2020</div>
        </h2>
      </header>
      <article style="margin-top: 2rem;">
		<p>24种设计模式汇总，不一定讲得很深，但是结合自己使用情况不断学习。</p>

<h1 id="table-of-contents"></h1><nav id="TableOfContents">
<ul>
<li><a href="#结构型">结构型</a>
<ul>
<li><a href="#06-装饰模式">06-装饰模式</a>
<ul>
<li><a href="#优点-缺点和使用场景">优点、缺点和使用场景</a></li>
<li><a href="#uml图">UML图</a></li>
<li><a href="#类实例代码">类实例代码</a></li>
<li><a href="#客户端代码">客户端代码</a></li>
</ul></li>
<li><a href="#07-代理模式">07-代理模式</a>
<ul>
<li><a href="#uml图-1">UML图</a></li>
<li><a href="#代理模式应用分析">代理模式应用分析</a></li>
<li><a href="#类实例代码-1">类实例代码</a></li>
<li><a href="#客户端实例代码">客户端实例代码</a></li>
</ul></li>
<li><a href="#12-外观模式">12-外观模式</a>
<ul>
<li><a href="#外观模式应用分析">外观模式应用分析</a></li>
<li><a href="#uml图-2">UML图</a></li>
<li><a href="#类实例代码-2">类实例代码</a></li>
<li><a href="#客户端代码-1">客户端代码</a></li>
</ul></li>
<li><a href="#17-适配器模式">17-适配器模式</a>
<ul>
<li><a href="#uml图-3">UML图</a></li>
<li><a href="#优点-缺点和适用环境">优点、缺点和适用环境</a></li>
<li><a href="#对象的适配器模式实现">对象的适配器模式实现</a>
<ul>
<li><a href="#类实例代码-3">类实例代码</a></li>
<li><a href="#客户端实例代码-1">客户端实例代码</a></li>
</ul></li>
<li><a href="#类的适配器模式实现">类的适配器模式实现</a></li>
</ul></li>
<li><a href="#19-组合模式">19-组合模式</a>
<ul>
<li><a href="#uml图-4">UML图</a></li>
<li><a href="#组合模式应用分析">组合模式应用分析</a></li>
<li><a href="#类实例代码-4">类实例代码</a></li>
<li><a href="#客户端代码-2">客户端代码</a></li>
</ul></li>
<li><a href="#22-桥接模式">22-桥接模式</a>
<ul>
<li><a href="#uml图-5">UML图</a></li>
<li><a href="#桥接模式应用分析">桥接模式应用分析</a></li>
<li><a href="#类实例代码-5">类实例代码</a></li>
<li><a href="#客户端实例代码-2">客户端实例代码</a></li>
</ul></li>
<li><a href="#26-享元模式">26-享元模式</a></li>
</ul></li>
</ul>
</nav>

<h1 id="结构型">结构型</h1>

<p>创建型的设计模式解决的是对象创建的问题，那结构型设计模式解决的是类和对象的组合关系的问题。</p>

<h2 id="06-装饰模式">06-装饰模式</h2>

<p>装饰模式简介：</p>

<p>装饰模式动态地给一个对象添加额外的职责。例如一幅画有没有画框都可以挂在墙上，画就是被装饰者。但是通常都是有画框的。在挂在墙上之前，画可以被蒙上玻璃，装到框子里，所以在画上加一层画框，并把它们组合成一个整体——有框的画。这样随着不断有新的装饰的加入，就给商品不断地打上包装，变成一个功能更让人满意的商品。这种不断打包装的过程就是装饰。</p>

<p>定义：</p>

<p>装饰模式提供了一种给类增加功能的方法。它通过动态地组合对象，可以给原有的类添加新的代码，而无须修改现有代码。因此引入bug或产生意外副作用的机会将大幅度减少。</p>

<p>装饰模式参与者：</p>

<ul>
<li>Component(抽象构件)：给出一个抽象接口，以规范准备接受附加职责的对象。</li>
<li>ConcreteComponent(具体构件)：定义一个将要接收附加责任的类。</li>
<li>Decorator(装饰)：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。</li>
<li>ConcreteDecorator(具体装饰)：负责向ConcreteComponent添加功能</li>
</ul>

<p>在装饰模式中，Decorator定义了一个装饰接口类。因为Decorator与ConcreteComponent继承同一个接口，所以继承Decorator的类ConcreteDecorator可以使用ConcreteComponent的方法，再在ConcreteDecorator里面加入一些新的方法，也就是装饰，就成为了一个包装好的装饰类。</p>

<h3 id="优点-缺点和使用场景">优点、缺点和使用场景</h3>

<p>优点：</p>

<ul>
<li>装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活</li>
<li>通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合</li>
<li>装饰者模式有很好地可扩展性</li>
</ul>

<p>缺点：</p>

<ul>
<li>装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会使得查错变得困难，特别是这些对象看上去都很像。</li>
</ul>

<p>使用场景：</p>

<ul>
<li>需要扩展一个类的功能或给一个类增加附加责任。</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</li>
<li>需要增加由一些基本功能的排列组合而产生的非常大量的功能</li>
</ul>

<h3 id="uml图">UML图</h3>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/Decorator.png" alt="" /></p>

<h3 id="类实例代码">类实例代码</h3>

<p>抽象构件（NoteBook）角色：</p>

<pre><code>/// &lt;summary&gt;
/// 笔记本抽象类，即装饰者模式中的抽象组件类
/// &lt;/summary&gt;
public abstract class NoteBook
{
    public abstract void SayHello();
}
</code></pre>

<p>具体构件（AppNotebook）角色：</p>

<pre><code>/// &lt;summary&gt;
/// 联想笔记本，即装饰着模式中的具体组件类
/// &lt;/summary&gt;
public class LenovoNoteBook : NoteBook
{
    public override void SayHello()
    {
        Console.WriteLine(&quot;我是联想笔记本&quot;);
    }
}
</code></pre>

<p>装饰（Dicorator）角色：</p>

<pre><code>/// &lt;summary&gt;
/// 装饰抽象类,要让装饰完全取代抽象组件，所以必须继承自NoteBook
/// &lt;/summary&gt;
public abstract class Decorator:NoteBook
{
    private NoteBook notebook;
    public Decorator(NoteBook n)
    {
        this.notebook = n;
    }
    public override void SayHello()
    {
        if(notebook!=null)
        {
            notebook.SayHello();
        }
    }
}
</code></pre>

<p>具体装饰（Sticker和Peripherals）角色：</p>

<pre><code>/// &lt;summary&gt;
/// 贴膜，即具体装饰者
/// &lt;/summary&gt;
public class Sticker : Decorator
{
    public Sticker(NoteBook n) : base(n)
    {
    }
    public override void SayHello()
    {
        base.SayHello();
        //添加新行为
        AddSticker();
    }

    /// &lt;summary&gt;
    /// 新的行为方法
    /// &lt;/summary&gt;
    public void AddSticker()
    {
        Console.WriteLine(&quot;给联想笔记本贴膜&quot;);
    }
}

/// &lt;summary&gt;
/// 外设，另一个具体装饰者
/// &lt;/summary&gt;
public class Peripherals : Decorator
{
    public Peripherals(NoteBook n) : base(n)
    {
    }
    public override void SayHello()
    {
        base.SayHello();
        //添加新行为
        AddPeripherals();
    }

    /// &lt;summary&gt;
    /// 新的行为方法
    /// &lt;/summary&gt;
    public void AddPeripherals()
    {
        Console.WriteLine(&quot;给联想笔记本加外设&quot;);
    }
}
</code></pre>

<h3 id="客户端代码">客户端代码</h3>

<p>代码如下：</p>

<pre><code>//创建联想笔记本对象
NoteBook notebook = new LenovoNoteBook();
//扩展贴膜行为
Decorator lenovowithsticker = new Sticker(notebook);
lenovowithsticker.SayHello();
Console.WriteLine(&quot;=======================&quot;);

//扩展增加外设行为
Decorator lenovowithperipherals = new Peripherals(notebook);
lenovowithperipherals.SayHello();
Console.WriteLine(&quot;=======================&quot;);

//同时扩展贴膜和增加外设行为
Sticker sticker = new Sticker(notebook);
Peripherals peripherals = new Peripherals(sticker);
peripherals.SayHello();
Console.ReadKey();
</code></pre>

<h2 id="07-代理模式">07-代理模式</h2>

<p>代理模式提供了一个中介控制对某个对象的访问。现实生活中，我们可能会用支票在市场交易中用来代替现金，支票就是账户中资金的代理。</p>

<p>代理模式简介：</p>

<p>代理模式（Proxy）定义：代理模式为客户端程序提供一种中间层以控制对这个对象的访问。</p>

<p>代理模式参与者：</p>

<ul>
<li>Proxy：维持一个引用，使得代理可以访问Subject。</li>
<li>Proxy：提供一个与Subject的接口相同的接口，这样代理就可以替代Subject。</li>
<li>Proxy：控制对Subject的访问，并可能负责对Subject的创建和删除。</li>
<li>Subject：定义ConcreteSubject与Proxy的共用接口，从而在任何使用ConcreteSubject的地方都可以使用Proxy。</li>
<li>ConcreteSubject：定义Proxy所代表的Subject。</li>
<li>Client：维持一个对Subject的引用。</li>
</ul>

<p>在代理模式中，由于Proxy与ConcreteSubject继承同一接口，所以Client调用ConcreteSubject可以转化为Client调用Proxy在调用ConcreteSubject，类Proxy为中间代理。</p>

<h3 id="uml图-1">UML图</h3>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/Proxy.png" alt="" /></p>

<h3 id="代理模式应用分析">代理模式应用分析</h3>

<p>代理模式适用范围很广，不同的代理适合于不同的情形。</p>

<ul>
<li>远程代理为一个对象在不同的地址空间提供局部代表。</li>
<li>虚代理在需要创建开销很大的对象时缓存对象信息。</li>
<li>保护代理控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。</li>
<li>智能指引取代了简单指引，它在访问对象时执行了一些附加操作。它的典型用途包括：对指向实际对象的引用计数，这样当该对象没有引用时，可以自动释放。当第一次引用一个持久对象时，将它装入内存。在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。</li>
</ul>

<p>代理模式特点：</p>

<ul>
<li>代理模式在访问对象时引入一定程度的间接性，可以隐藏对象的位置。</li>
<li>代理模式可以对用户隐藏一种称之为copy-on-write的优化方式。当进行一个开销很大的复制操作的时候，如果复制没有被修改，则代理延迟这一复制过程，这一可以保证只有当这个对象被修改的时候才对它进行复制。</li>
</ul>

<p>代理模式与装饰模式比较分析:</p>

<p>装饰器模式关注于在一个对象上动态的添加方法，代理模式关注于控制对对象的访问。</p>

<p>装饰器模式中Decorator和ConcreteComponent都实现Component，代理模式中Proxy和ConcreteSubject都实现Subject。使用这两种模式，都可以很容易地在具体对象的方法前面或者后面加上自定义的方法。</p>

<p>Proxy 可以对Client隐藏对象的具体信息，在使用代理模式时，常在Proxy中创建一个对象的实例。Proxy与ConcreteSubject之间的关系在编译时就能确定。</p>

<p>在使用装饰模式时，常是将ConcreteComponent对象作为一个参数传给ConcreteDecorator的构造器，Decorator在运行时递归的被构造。</p>

<h3 id="类实例代码-1">类实例代码</h3>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// The 'Subject interface
/// &lt;/summary&gt;
public interface IMath
{
    double Add(double x, double y);
    double Sub(double x, double y);
    double Mul(double x, double y);
    double Div(double x, double y);
}

/// &lt;summary&gt;
/// The 'ConcreteSubject' class
/// &lt;/summary&gt;
public class Math : IMath
{
    public double Add(double x, double y)
    {
        return x + y;
    }
    public double Sub(double x, double y)
    {
        return x - y;
    }
    public double Mul(double x, double y)
    {
        return x * y;
    }
    public double Div(double x, double y)
    {
        return x / y;
    }
}

/// &lt;summary&gt;
/// 代理
/// &lt;/summary&gt;
public class MathProxy : IMath
{
    private Math _math = new Math();

    public double Add(double x, double y)
    {
        return _math.Add(x, y);
    }

    public double Sub(double x, double y)
    {
        return _math.Sub(x, y);
    }

    public double Mul(double x, double y)
    {
        return _math.Mul(x, y);
    }

    public double Div(double x, double y)
    {
        return _math.Div(x, y);
    }
}
</code></pre>

<h3 id="客户端实例代码">客户端实例代码</h3>

<p>代码如下：</p>

<pre><code>// Create math proxy
MathProxy proxy = new MathProxy();

// Do the math
Console.WriteLine(&quot;4 + 2 = &quot; + proxy.Add(4, 2));
Console.WriteLine(&quot;4 - 2 = &quot; + proxy.Sub(4, 2));
Console.WriteLine(&quot;4 * 2 = &quot; + proxy.Mul(4, 2));
Console.WriteLine(&quot;4 / 2 = &quot; + proxy.Div(4, 2));
</code></pre>

<h2 id="12-外观模式">12-外观模式</h2>

<p>简介:</p>

<p>外观模式主要解决的问题：当有多个类要处理时，需要一个个类去调用，没有复用性和扩展性。外观模式将处理子类的过程封装成操作，简化客户端的调用过程。</p>

<p>定义:</p>

<p>外观模式（Facade）通过提供一个统一接口，来访问子系统的多个接口。</p>

<p>使用外观模式时，创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以直接通过外观类来调用内部子系统中方法。外观模式让客户端与子系统之间避免紧耦合。</p>

<p>外观模式参与者：</p>

<ul>
<li>Facade：知道哪些子系统类负责处理请求；将客户的请求代理给相应的子系统对象。</li>
<li>Subsystem Classes：实现子系统的功能；处理由Facade对象指派的任务来协调子系统下各子类的调用方式。</li>
</ul>

<p>在外观模式中，外观类Facade的方法OptionWrapper实现的就是以不同的次序调用下面类SubSystem1、SubSystem2的方法Operation，通过不同的Operation组合实现装饰功能。</p>

<h3 id="外观模式应用分析">外观模式应用分析</h3>

<p>外观模式适用情形：</p>

<ul>
<li>当要为一个复杂子系统提供一个简单接口时，子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类，这使得子系统更具可用性，也更容易对子系统进行定制。但这也给那些不需要定制子系统的用户带来一些使用上的困难。外观模式可以提供一个简单的默认视图。这一视图对大多数用户来说已经足够，而那些需要更多定制性的用户可以越过Facade层。</li>
<li>客户程序与抽象类的实现部分之间存在着很大的依赖性。引入外观模式将这个子系统与客户以及其他子系统分离，可以提高该子系统的独立性和可移植性。</li>
<li>当需要构建有层次结构的子系统时，使用外观模式定义每层的入口点。如果子系统间相互依赖，它们只需通过外观进行通信，从而简化它们之间的依赖关系.</li>
</ul>

<p>外观模式特点：</p>

<ul>
<li>它实现了子系统对客户的屏蔽，因而减少了客户处理的对象数目并且使子系统使用起来更加方便。</li>
<li>它实现了子系统与客户之间的松耦合关系。而子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。</li>
<li>外观模式有助于建立系统的层次结构，也有助于对对象之间的依赖关系分层。</li>
<li>外观模式可以消除复杂的循环依赖关系。这一点在客户程序与子系统是分别实现的时候尤为重要。在大型软件系统中降低编译依赖性至关重要。在子系统类改变时，希望尽量减少重编译工作以节省时间。</li>
<li>用外观模式可以降低编译依赖性，减少对重要系统做较小的改变所需的重编译工作。</li>
<li>外观模式有利于简化系统在不同平台之间的移植过程。因为编译一个子系统一般不需要编译所有其他子系统。</li>
<li>如果应用需要，外观模式并不限制子系统类的使用。因此可以在系统易用性和通用性之间加以选择。</li>
</ul>

<h3 id="uml图-2">UML图</h3>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/Facade.png" alt="" /></p>

<h3 id="类实例代码-2">类实例代码</h3>

<p>代码如下：</p>

<pre><code>#region 分系统    
public class SubSystemOne
{
    public void MethodOne()
    {
        Console.WriteLine(&quot; SubSystemOne Method&quot;);
    }
}

public class SubSystemTwo
{
    public void MethodTwo()
    {
        Console.WriteLine(&quot; SubSystemTwo Method&quot;);
    }
}

public class SubSystemThree
{
    public void MethodThree()
    {
        Console.WriteLine(&quot; SubSystemThree Method&quot;);
    }
}

public class SubSystemFour
{
    public void MethodFour()
    {
        Console.WriteLine(&quot; SubSystemFour Method&quot;);
    }
}
#endregion

#region Facade
public class Facade
{
    private SubSystemOne _one;
    private SubSystemTwo _two;
    private SubSystemThree _three;
    private SubSystemFour _four;

    public Facade()
    {
        _one = new SubSystemOne();
        _two = new SubSystemTwo();
        _three = new SubSystemThree();
        _four = new SubSystemFour();
    }

    public void MethodA()
    {
        Console.WriteLine(&quot;\nMethodA() ---- &quot;);
        _one.MethodOne();
        _two.MethodTwo();
        _four.MethodFour();
    }

    public void MethodB()
    {
        Console.WriteLine(&quot;\nMethodB() ---- &quot;);
        _two.MethodTwo();
        _three.MethodThree();
    }
}
#endregion
</code></pre>

<h3 id="客户端代码-1">客户端代码</h3>

<p>代码如下：</p>

<pre><code>Facade facade = new Facade();
facade.MethodA();
facade.MethodB();
</code></pre>

<h2 id="17-适配器模式">17-适配器模式</h2>

<p>简介：</p>

<p>适配器模式属于结构型模式，把一个类的接口变成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p>

<p>适配器模式又可以分为4种类型，类适配器模式、对象适配器模式、单接口适配器模式（缺省适配器模式）和双向适配器模式。后2种模式的实现比较复杂并且在实际开发过程中很少使用，故本文只讨论前2种模式。</p>

<p>角色：</p>

<ul>
<li>抽象目标(Target)：抽象目标类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于C#语言不支持多重继承，所以它只能是接口；</li>
<li>客户角色（Client）：与符合Target接口的对象协同。</li>
<li>适配器角色(Adapter)：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配；</li>
<li>适配者(Adaptee)：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类包好了客户希望的业务方法。</li>
</ul>

<h3 id="uml图-3">UML图</h3>

<p>对象适配器（更常用）：</p>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/ObjectAdapter.png" alt="" /></p>

<p>对象适配器使用的是对象组合的方案，它的Adapter核Adaptee的关系是组合关系。</p>

<p>OO中优先使用组合模式，组合模式不适用再考虑继承。因为组合模式更加松耦合，而继承是紧耦合的，父类的任何改动都要导致子类的改动。</p>

<p>类适配器：</p>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/ClassAdapter.png" alt="" /></p>

<h3 id="优点-缺点和适用环境">优点、缺点和适用环境</h3>

<p>实现要点：</p>

<ul>
<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</li>
<li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。类适配器采用“多继承”的实现方式，在C#语言中，如果被适配角色是类，Target的实现只能是接口，因为C#语言只支持接口的多继承的特性。在C#语言中类适配器也很难支持适配多个对象的情况，同时也会带来了不良的高耦合和违反类的职责单一的原则，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神，对适配的对象也没限制，可以一个，也可以多个，但是，使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</li>
<li>Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便地适配。</li>
</ul>

<p>配器模式用来解决现有对象与客户端期待接口不一致的问题，下面详细总结下适配器两种形式的优缺点。</p>

<p>类的适配器模式：</p>

<p>优点：</p>

<ul>
<li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”；</li>
<li>可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类；</li>
<li>仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。</li>
</ul>

<p>缺点：</p>

<ul>
<li>用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。</li>
<li>采用了 “多继承”的实现方式，带来了不良的高耦合。</li>
</ul>

<p>对象的适配器模式：</p>

<p>优点：</p>

<ul>
<li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的）</li>
<li>采用 “对象组合”的方式，更符合松耦合。</li>
</ul>

<p>缺点：</p>

<ul>
<li>使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。</li>
</ul>

<p>适配器模式使用的场景：</p>

<ul>
<li>系统需要复用现有类，而该类的接口不符合系统的需求；</li>
<li>想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作；</li>
<li>对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。</li>
</ul>

<h3 id="对象的适配器模式实现">对象的适配器模式实现</h3>

<h4 id="类实例代码-3">类实例代码</h4>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// 我家只有2个孔的插座，也就是适配器模式中的目标(Target)角色，这里可以写成抽象类或者接口
/// &lt;/summary&gt;
public class TwoHoleTarget
{
    // 客户端需要的方法
    public virtual void Request()
    {
        Console.WriteLine(&quot;两孔的充电器可以使用&quot;);
    }
}

/// &lt;summary&gt;
/// 手机充电器是有3个柱子的插头，源角色——需要适配的类（Adaptee）
/// &lt;/summary&gt;
public class ThreeHoleAdaptee
{
    public void SpecificRequest()
    {
        Console.WriteLine(&quot;我是3个孔的插头也可以使用了&quot;);
    }
}

/// &lt;summary&gt;
/// 适配器类，TwoHole这个对象写成接口或者抽象类更好，面向接口编程嘛
/// &lt;/summary&gt;
public class ThreeToTwoAdapter : TwoHoleTarget
{
    // 引用两个孔插头的实例,从而将客户端与TwoHole联系起来
    private ThreeHoleAdaptee threeHoleAdaptee = new ThreeHoleAdaptee();
    //这里可以继续增加适配的对象。。

    /// &lt;summary&gt;
    /// 实现2个孔插头接口方法
    /// &lt;/summary&gt;
    public override void Request()
    {
        //可以做具体的转换工作
        threeHoleAdaptee.SpecificRequest();
        //可以做具体的转换工作
    }
}
</code></pre>

<h4 id="客户端实例代码-1">客户端实例代码</h4>

<p>代码如下：</p>

<pre><code>//好了，现在就可以给手机充电了
TwoHoleTarget homeTwoHole = new ThreeToTwoAdapter();
homeTwoHole.Request();
Console.ReadLine();
</code></pre>

<h3 id="类的适配器模式实现">类的适配器模式实现</h3>

<p>代码如下：</p>

<pre><code>/// &lt;summary&gt;
/// 这里手机充电器为例，我们的家的插座是两相电的，但是手机的插座接头是三相电的
/// &lt;/summary&gt;
class Client
{
    static void Main(string[] args)
    {
        //好了，现在可以充电了
        ITwoHoleTarget change = new ThreeToTwoAdapter();
        change.Request();
        Console.ReadLine();
    }
}

/// &lt;summary&gt;
/// 我家只有2个孔的插座，也就是适配器模式中的目标角色（Target），这里只能是接口，也是类适配器的限制
/// &lt;/summary&gt;
public interface ITwoHoleTarget
{
    void Request();
}

/// &lt;summary&gt;
/// 3个孔的插头，源角色——需要适配的类（Adaptee）
/// &lt;/summary&gt;
public abstract class ThreeHoleAdaptee
{
    public void SpecificRequest()
    {
        Console.WriteLine(&quot;我是三个孔的插头&quot;);
    }
}

/// &lt;summary&gt;
/// 适配器类，接口要放在类的后面，在此无法适配更多的对象，这是类适配器的不足
/// &lt;/summary&gt;
public class ThreeToTwoAdapter:ThreeHoleAdaptee,ITwoHoleTarget
{
    /// &lt;summary&gt;
    /// 实现2个孔插头接口方法
    /// &lt;/summary&gt;
    public void Request()
    {
        // 调用3个孔插头方法
        this.SpecificRequest();
    }
}
</code></pre>

<h2 id="19-组合模式">19-组合模式</h2>

<p>简介：</p>

<p>组合模式主要用来处理一类具有“容器特征”的对象——即它们在充当对象的同时，又可以作为容器包含其他多个对象。</p>

<p>参与者：</p>

<ul>
<li>Component：声明组合中对象的接口；实现全部类中公共接口的默认行为；声明访问和管理子类的接口；（可选择）定义接口提供在递归结构中访问父类。</li>
<li>Composite：定义Component子类的行为；保存Component子类；实现Component接口的子类关联操作。</li>
<li>Leaf：表示在组合对象中叶子节点对象，没有子节点；定义组合对象中的初始行为。</li>
<li>Client：通过Component接口组合多个对象。</li>
</ul>

<h3 id="uml图-4">UML图</h3>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/Composite.png" alt="" /></p>

<h3 id="组合模式应用分析">组合模式应用分析</h3>

<p>组合模式可以适用以下情形：</p>

<ul>
<li>希望把对象表示成部分—整体层次结构；</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中所有对象。</li>
</ul>

<p>组合模式具有以下特点：</p>

<ul>
<li>定义了包含基本对象和组合对象的类层次结构。基本对象可以被组合成更复杂的组合对象，而这个组合对象又可以被组合，不断的递归下去。客户代码中，任何用到基本对象的地方都可以使用组合对象；</li>
<li>简化客户代码。客户可以一致地使用组合结构和单个对象。这样用户就不必关心处理的是一个叶子节点还是一个组合组件，从而简化了客户代码；</li>
<li>使得新增类型的组件更加容易。新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起协同工作，客户程序不需因新的Component类而改变。</li>
</ul>

<h3 id="类实例代码-4">类实例代码</h3>

<p>代码如下：</p>

<pre><code>public abstract class Shape
{
    protected string _name;

    public Shape(string name)
    {
        this._name = name;
    }

    /// &lt;summary&gt;
    /// 面积
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public abstract double Area();

    /// &lt;summary&gt;
    /// 显示
    /// &lt;/summary&gt;
    public abstract void Display();
}

/// &lt;summary&gt;
/// 圆形
/// &lt;/summary&gt;
public class Circle : Shape
{
    private double _radius;

    public Circle(string name, double radius)
        : base(name)
    {
        this._radius = radius;
    }

    public override double Area()
    {
        return Math.Round(Math.PI * _radius * _radius, 2);
    }

    public override void Display()
    {
        Console.WriteLine(&quot;{0} 半径：{1}，面积：{2}&quot;, _name, _radius, this.Area());
    }
}

/// &lt;summary&gt;
/// 矩形
/// &lt;/summary&gt;
public class Rectangle : Shape
{
    private double _width;
    private double _height;

    public Rectangle(string name, double width, double height)
        : base(name)
    {
        this._width = width;
        this._height = height;
    }

    public override double Area()
    {
        return _width * _height;
    }

    public override void Display()
    {
        Console.WriteLine(&quot;{0} 长：{1}，宽：{2}，面积：{3}&quot;, _name, _width, _height, this.Area());
    }
}

/// &lt;summary&gt;
/// 三角形
/// &lt;/summary&gt;
public class Triangle : Shape
{
    private double _a;
    private double _b;
    private double _c;

    /// &lt;summary&gt;
    /// 三角形构造函数
    /// 参数：三角形名称和三条边长
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;name&quot;&gt;三角形名称&lt;/param&gt;
    /// &lt;param name=&quot;a&quot;&gt;第一条边长&lt;/param&gt;
    /// &lt;param name=&quot;b&quot;&gt;第二条边长&lt;/param&gt;
    /// &lt;param name=&quot;c&quot;&gt;第三条边长&lt;/param&gt;
    public Triangle(string name, double a, double b, double c)
        : base(name)
    {
        _a = a;
        _b = b;
        _c = c;
    }

    public override double Area()
    {
        double p = (_a + _b + _c) / 2;
        return Math.Sqrt(p * (p - _a) * (p - _b) * (p - _c));
    }

    public override void Display()
    {
        Console.WriteLine(&quot;{0} 三条边长：{1}，{2}，{3},面积：{3}&quot;, _name, _a, _b, _c, this.Area());
    }
}

public class Graphics : Shape
{
    private List&lt;Shape&gt; _children = new List&lt;Shape&gt;();

    public Graphics(string name)
        : base(name)
    { }

    public override double Area()
    {
        double sum = 0;
        foreach (Shape child in _children)
        {
            sum += child.Area();
        }
        return sum;
    }

    public override void Display()
    {
        foreach (Shape child in _children)
        {
            child.Display();
        }

        Console.WriteLine(&quot;{0} 总面积：{1}&quot;, _name, this.Area());
    }

    public void Add(Shape child)
    {
        _children.Add(child);
    }

    public void Remove(Shape child)
    {
        _children.Remove(child);
    }
}
</code></pre>

<h3 id="客户端代码-2">客户端代码</h3>

<p>代码如下：</p>

<pre><code>Graphics graphics = new Graphics(&quot;全部图形&quot;);

Circle circle = new Circle(&quot;圆形&quot;, 5);
graphics.Add(circle);

Rectangle rectangle = new Rectangle(&quot;矩形&quot;, 4, 5);
graphics.Add(rectangle);

Triangle triangle = new Triangle(&quot;三角形&quot;, 3, 4, 5);
graphics.Add(triangle);

graphics.Display();
</code></pre>

<h2 id="22-桥接模式">22-桥接模式</h2>

<p>简介：</p>

<p>一个抽象可能有多个实现时，通常用继承来进行协调。抽象类定义对该抽象的接口，而具体的子类则用不同的方式加以实现。继承机制将抽象部分与它的实现部分固定在一起，使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。</p>

<p>如果一个抽象类或接口有多个具体实现子类，而这些子类之中有内容或概念上重叠，需要我们把抽象的共同部分各自独立开来：即原来是准备放在一个接口里，现在需要设计两个接口——抽象接口和行为接口。然后再分别针对各自的具体子类定义抽象接口和行为接口的方法和调用关系。</p>

<p>桥接模式的用意是将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。</p>

<p>抽象化(Abstraction)：</p>

<p>存在于多个实体中的共同的概念性联系，即为抽象化。作为一个过程，抽象化就是忽略一些信息，从而把不同的实体当做同样的实体对待。</p>

<p>实现化(Implementation)：</p>

<p>抽象化给出的具体实现，即为实现化。</p>

<p>脱耦：</p>

<ul>
<li>耦合是指两个对象的行为的某种强关联，脱耦则是要去掉它们之间的强关联。在这里，脱耦是指将抽象化和实现化之间的耦合解脱，或者将它们之间的强关联改换成弱关联。将两者之间的继承关系改为聚合关系，就是将它们之间的强关联改换成为弱关联。</li>
<li>桥接模式中的脱耦，是指抽象化和实现化之间使用组合/聚合关系，而不是继承关系，从而使两者可以相对独立地变化。</li>
</ul>

<p>参与者：</p>

<ul>
<li>Abstraction：定义抽象类的接口，它维护了一个指向Implementor类型对象的指针；</li>
<li>RefinedAbstraction：扩充由Abstraction定义的接口；</li>
<li>Implementor：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致，事实上两个接口可以完全不同。一般情况，Implementor接口仅为提供基本操作，而Abstraction则定义了基于基本操作的较高层次操作；</li>
<li>ConcreteImplementorA和ConcreteImplementorB：实现Implementor接口并定义它的具体实现。</li>
</ul>

<p>在桥接模式中，两个类Abstraction和Implementor分别定义了抽象与行为类型的接口，通过调用两接口的子类实现抽象与行为的动态组合。</p>

<h3 id="uml图-5">UML图</h3>

<p><img src="https://sltaurusblog.gitee.io/images/Pattern/Bridge.png" alt="" /></p>

<h3 id="桥接模式应用分析">桥接模式应用分析</h3>

<p>桥接模式可以适用于以下情形：</p>

<ul>
<li>不希望在抽象与实现部分之间有固定的绑定关系；</li>
<li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时桥接模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充；</li>
<li>对抽象的实现部分进行修改应对客户不产生影响，即客户的代码不必重新编译；</li>
<li>想对客户完全隐藏抽象的实现部分；</li>
<li>想在多个对象间共享实现，但同时要求客户并不知道这点。</li>
</ul>

<p>桥接模式具有以下特点：</p>

<ul>
<li>分离接口及其实现部分，一个实现未必不变地绑定在一个接口上。抽象类的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现；</li>
<li>将Abstraction与Implementor分离有助于降低对实现部分编译时刻的依赖性；当改变一个实现类时，并不需要重新编译Abstraction类和Client类。为了保证一个类库的不同版本之间的兼容，需要有这个特性；</li>
<li>接口与实现分离有助于分层，从而产生更好的结构化系统。系统的高层部分仅需要知道Abstraction和Implementor即可；</li>
<li>提高可扩充性。可以独立的对Abstraction和Implementor层次结构进行扩充；</li>
<li>实现细节对Client透明。可以对Client隐藏实现细节，如共享Implementor对象以及相应的引用计数机制。</li>
</ul>

<h3 id="类实例代码-5">类实例代码</h3>

<p>代码如下：</p>

<pre><code>public abstract class MakeCoffee
{
    public abstract void Making();
}

/// &lt;summary&gt;
/// 单件模式类用来加载当前MakeCoffee
/// &lt;/summary&gt;
public sealed class MakeCoffeeSingleton
{
    private static MakeCoffee _instance;

    public MakeCoffeeSingleton(MakeCoffee instance)
    {
        _instance = instance;
    }

    public static MakeCoffee Instance()
    {
        return _instance;
    }
}

/// &lt;summary&gt;
/// 咖啡
/// &lt;/summary&gt;
public abstract class Coffee
{
    private MakeCoffee _makeCoffee;

    public Coffee()
    {
        _makeCoffee = MakeCoffeeSingleton.Instance();
    }

    public MakeCoffee MakeCoffee()
    {
        return this._makeCoffee;
    }

    public abstract void Make();
}

/// &lt;summary&gt;
/// 原味咖啡
/// &lt;/summary&gt;
public class BlackCoffee : MakeCoffee
{
    public override void Making()
    {
        Console.WriteLine(&quot;原味咖啡&quot;);
    }
}

/// &lt;summary&gt;
/// 牛奶咖啡
/// &lt;/summary&gt;
public class WhiteCoffee : MakeCoffee
{
    public override void Making()
    {
        Console.WriteLine(&quot;牛奶咖啡&quot;);
    }
}

/// &lt;summary&gt;
/// 中杯
/// &lt;/summary&gt;
public class MediumCupCoffee : Coffee
{
    public override void Make()
    {
        MakeCoffee makeCoffee = this.MakeCoffee();
        Console.Write(&quot;中杯&quot;);
        makeCoffee.Making();
    }
}

/// &lt;summary&gt;
/// 大杯
/// &lt;/summary&gt;
public class LargeCupCoffee : Coffee
{
    public override void Make()
    {
        MakeCoffee makeCoffee = this.MakeCoffee();
        Console.Write(&quot;大杯&quot;);
        makeCoffee.Making();
    }
}
</code></pre>

<h3 id="客户端实例代码-2">客户端实例代码</h3>

<p>代码如下：</p>

<pre><code>MakeCoffeeSingleton whiteCoffeeSingleton = new MakeCoffeeSingleton(new WhiteCoffee());

// 中杯牛奶咖啡
MediumCupCoffee mediumWhiteCoffee = new MediumCupCoffee();
mediumWhiteCoffee.Make();

// 大杯牛奶咖啡
LargeCupCoffee largeCupWhiteCoffee = new LargeCupCoffee();
largeCupWhiteCoffee.Make();

MakeCoffeeSingleton blackCoffeeSingleton = new MakeCoffeeSingleton(new BlackCoffee());
// 中杯原味咖啡
MediumCupCoffee mediumBlackCoffee = new MediumCupCoffee();
mediumBlackCoffee.Make();

// 大杯牛奶咖啡
LargeCupCoffee largeCupBlackCoffee = new LargeCupCoffee();
largeCupBlackCoffee.Make();
</code></pre>

<h2 id="26-享元模式">26-享元模式</h2>
	  </article>
    </section>

    <footer class="ui attached segment dream-tags">
      
        
          <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B" title="设计模式-结构型">设计模式-结构型</a>
        
      
      <div
        class="ui label"
        style="float: right; background: #1b1c1d !important; cursor: pointer;"
        onclick="savePostAsImg()">
        <i class="save icon"></i> Save as image
      </div>
    </footer>

    

    
      <footer class="ui bottom attached stacked segment post-disqus-area" data-html2canvas-ignore="true">
        <div id="disqus_thread"></div>
        <script>
          


          var disqus_config = function () {
            this.page.url = 'https:\/\/sltaurusblog.gitee.io\/2020\/04\/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B\/';  
            this.page.identifier = '\/2020\/04\/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B\/'; 
          };

          (function() { 
            var d = document, s = d.createElement('script');
            s.src = 'https://' + '...' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </footer>
    

  </div>
  <div class="sixteen wide mobile sixteen wide tablet four wide computer column">
    <article class="dream-header">
  <section class="ui top attached center aligned segment">
    <div class="ui small circular image">
      
        <img src="https://sltaurusblog.gitee.io/images/head.jpg">
      
    </div>

    <h1 class="ui medium header">SLTaurus的博客<div class="sub header" style="margin-top: 0.5rem;">合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。</div>
    </h1>

    <div class="ui horizontal list">
      
      <a class="item" href="https://sltaurusblog.gitee.io/tags">
        <i class="tags icon" title="所有标签"></i>
      </a>
      <a class="item" href="https://sltaurusblog.gitee.io/categories">
        <i class="th list icon" title="所有分类"></i>
      </a>
    </div>
  </section>

  
  <section class="ui attached center aligned segment dream-tags">
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ado.net" title="ado.net">ado.net</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ef" title="ef">ef</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/hugo" title="hugo">hugo</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/javascript" title="javascript">javascript</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8" title="markdown快速入门">markdown快速入门</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95%E5%AE%8C%E6%95%B4%E7%89%88" title="markdown语法完整版">markdown语法完整版</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/mvc" title="mvc">mvc</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/mysql" title="mysql">mysql</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/orm%E5%AF%B9%E6%AF%94" title="orm对比">orm对比</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/orm%E6%95%B4%E7%90%86" title="orm整理">orm整理</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/powershell" title="powershell">powershell</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/redis" title="redis">redis</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ref%E5%92%8Cout" title="ref和out">ref和out</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/sqlservice" title="sqlservice">sqlservice</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98" title="内置泛型委托">内置泛型委托</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E5%8F%8D%E5%B0%84" title="反射">反射</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E7%B2%BE%E9%80%9Ac" title="精通c#">精通c#</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B" title="设计模式-创建型">设计模式-创建型</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99" title="设计模式-原则">设计模式-原则</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B" title="设计模式-结构型">设计模式-结构型</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E9%A1%B9%E7%9B%AE" title="项目">项目</a>
    
  </section>
  

  
  <section class="ui attached segment dream-categories">
    <div class="ui accordion">
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/c" class="item">c#</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/11/%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98actionfunc%E5%92%8Cpredicate/" class="item">内置泛型委托：Action、Func和Predicate</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/%E5%8F%8D%E5%B0%84%E6%95%B4%E7%90%86%E4%B9%8B%E6%97%A5%E5%B8%B8%E7%94%A8%E9%80%94/" class="item">反射整理之日常用途</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/ado.net/" class="item">ADO.NET</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/mvc%E6%95%B4%E7%90%86/" class="item">MVC整理</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/%E7%B2%BE%E9%80%9Acsharp%E7%AC%AC%E5%85%AD%E7%89%88/" class="item">精通CSharp(第六版)</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/ref%E5%92%8Cout%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/" class="item">ref和out使用时的区别</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/javascript" class="item">javascript</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/" class="item">JavaScript入门经典第6版笔记(下)</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" class="item">JavaScript入门经典第6版笔记(上)</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/markdown" class="item">markdown</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/markdown%E8%AF%AD%E6%B3%95%E5%AE%8C%E6%95%B4%E7%89%88/" class="item">Markdown语法完整版</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="item">Markdown快速入门</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/orm" class="item">orm</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/efchloesqlsugardos.orm%E5%9B%9B%E7%A7%8Dorm%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AF%B9%E6%AF%94/" class="item">EF、Chloe、SqlSugar、DOS.ORM四种ORM框架的对比 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/entityframework/" class="item">EntityFramework</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/orm%E6%95%B4%E7%90%86/" class="item">ORM整理</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/redis" class="item">redis</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/06/redis%E5%9F%BA%E7%A1%80/" class="item">Redis基础</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E5%8D%9A%E5%AE%A2" class="item">博客</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/windows10%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-valine%E8%AF%84%E8%AE%BA/" class="item">windows10环境下搭建Hugo个人博客&#43;git分布式版本控制&#43;valine评论</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93" class="item">数据库</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/mysql%E6%8B%BE%E9%81%97/" class="item">MySql拾遗 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/sqlservice%E7%AC%94%E8%AE%B0/" class="item">SqlService笔记</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96" class="item">自动化</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/windows-powershell%E6%8C%87%E5%8D%97/" class="item">Windows PowerShell指南</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="item">设计模式</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/" class="item">24种设计模式之设计模式原则 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B/" class="item">24种设计模式之行为型 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" class="item">24种设计模式之结构型 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/" class="item">24种设计模式之创建型 </a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E9%A1%B9%E7%9B%AE" class="item">项目</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/05/%E8%AE%A1%E4%BB%B6%E5%B7%A5%E8%B5%84%E9%A1%B9%E7%9B%AE/" class="item">计件工资项目</a>
              </div>
            </div>
          
          </div>
        </div>
      
    </div>
  </section>
  

  <section class="ui attached segment header-socials">
    <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <a href="mailto:1641061313@qq.com">
        <i class=" mail icon" title="email"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://twitter.com/SLTaurus" target="_blank">
        <i class=" twitter icon" title="twitter"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://facebook.com/SLTaurus" target="_blank">
        <i class=" facebook icon" title="facebook"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://instagram.com/SLTaurus" target="_blank">
        <i class=" instagram icon" title="instagram"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.linkedin.com/in/SLTaurus" target="_blank">
        <i class=" linkedin icon" title="linkedin"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://github.com/SLTaurus" target="_blank">
        <i class=" github icon" title="github"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.stackoverflow.com/users/SLTaurus" target="_blank">
        <i class=" stack overflow icon" title="stackoverflow"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://codepen.io/SLTaurus" target="_blank">
        <i class=" codepen icon" title="codepen"></i>
      </a>
    </div>
  
</nav>

  </section>

  <section class="ui bottom attached center aligned segment">
    
      <p>© 2019 - 2020 SLTaurus的博客</p>
    

    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>
  </section>
</article>

  </div>
</div>

        </section>
        <section class="back">
          
<nav class="ui secondary inverted menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/sltaurusblog.gitee.io'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          <div class="ui centered relaxed grid dream-grid dream-back">
  

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article>
      <div class="ui top attached segment">
        <h3 class="ui header">社交链接</h3>
      </div>
      <div class="ui attached segment">
        <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <a href="mailto:1641061313@qq.com">
        <i class="large mail icon" title="email"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://twitter.com/SLTaurus" target="_blank">
        <i class="large twitter icon" title="twitter"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://facebook.com/SLTaurus" target="_blank">
        <i class="large facebook icon" title="facebook"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://instagram.com/SLTaurus" target="_blank">
        <i class="large instagram icon" title="instagram"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.linkedin.com/in/SLTaurus" target="_blank">
        <i class="large linkedin icon" title="linkedin"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://github.com/SLTaurus" target="_blank">
        <i class="large github icon" title="github"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.stackoverflow.com/users/SLTaurus" target="_blank">
        <i class="large stack overflow icon" title="stackoverflow"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://codepen.io/SLTaurus" target="_blank">
        <i class="large codepen icon" title="codepen"></i>
      </a>
    </div>
  
</nav>

      </div>
    </article>
  </section>

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
  </section>

  
  
    <section class="sixteen wide mobile eight wide tablet eight wide computer column dream-column">
      <footer class="ui segment">
        <div id="disqus_thread"></div>
        <script>
          


          var disqus_config = function () {
            this.page.url = 'https:\/\/sltaurusblog.gitee.io\/2020\/04\/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B\/about';  
            this.page.identifier = '/about'; 
          };

          (function() { 
            var d = document, s = d.createElement('script');
            s.src = 'https://' + '...' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </footer>
    </section>
  

</div>

        </section>
      </div>
    </div>

    <script src="https://sltaurusblog.gitee.io/js/jquery.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/semantic.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/imagesloaded.pkgd.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/masonry.pkgd.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/nav.js"></script>
<script src="https://sltaurusblog.gitee.io/js/header.js"></script>
<script src="https://sltaurusblog.gitee.io/js/main.js"></script>
<script src="https://sltaurusblog.gitee.io/js/theme.js"></script>
<script src="https://sltaurusblog.gitee.io/js/html2canvas.min.js"></script>

  
    <script src="https://sltaurusblog.gitee.io/js/prism.js"></script>
  


  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', '...', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  </body>
</html>
