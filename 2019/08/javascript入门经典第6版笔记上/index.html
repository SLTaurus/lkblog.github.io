<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>
JavaScript入门经典第6版笔记(上)
</title>

    
  <link href="https://sltaurusblog.gitee.io/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />



  
  <meta name="author" content="SLTaurus" />
  <meta name="description" content="SLTaurus的博客" />



<meta name="generator" content="Hugo 0.57.2" />

<link rel="canonical" href="https://sltaurusblog.gitee.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" />


<meta property="og:title" content="JavaScript入门经典第6版笔记(上)" />
<meta property="og:description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sltaurusblog.gitee.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" />
<meta property="article:published_time" content="2019-08-29T08:39:39+08:00" />
<meta property="article:modified_time" content="2019-08-29T08:39:39+08:00" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="JavaScript入门经典第6版笔记(上)"/>
<meta name="twitter:description" content="这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。"/>


<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/github-markdown.css" />
<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/semantic.min.css" />
<link rel="stylesheet" href="https://sltaurusblog.gitee.io/css/site.css" />


  
    <link rel="stylesheet"  href="https://sltaurusblog.gitee.io/css/prism.css">
  



<style>
  a {
    color: seagreen !important;
  }
</style>



<style>
  .inverted a {
     color: darkseagreen !important;
  }
</style>


  </head>

  
  <body style="background: black;">
  
    <div class="flip-container">
      <div class="flipper">
        <section class="front">
          
<nav class="ui secondary inverted menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/sltaurusblog.gitee.io'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          
<div class="ui centered relaxed grid dream-grid">
  <div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single">

    <section class="ui top attached segment" id="dream-save-post-as-img">
      <header style="margin-top: 0 !important;">
        <h2 class="ui header">
          JavaScript入门经典第6版笔记(上)
          <div class="sub header">@ SLTaurus · Thursday, Aug 29, 2019 · 50 分钟阅读 · 更新于 Aug 29, 2019</div>
        </h2>
      </header>
      <article style="margin-top: 2rem;">
		<p>这里较为记录下JavaScript入门经典第6版的看书笔记，用来大家入门需要和自己温故知新。</p>

<h1 id="table-of-contents"></h1><nav id="TableOfContents">
<ul>
<li><a href="#javascript基础">JavaScript基础</a>
<ul>
<li><a href="#服务器段和客户端编程">服务器段和客户端编程</a></li>
<li><a href="#dom简介">DOM简介</a></li>
<li><a href="#script标签">script标签</a></li>
<li><a href="#函数">函数</a></li>
</ul></li>
<li><a href="#javascript编程">JavaScript编程</a>
<ul>
<li><a href="#与用户交互的弹窗">与用户交互的弹窗</a></li>
<li><a href="#捕获鼠标事件">捕获鼠标事件</a></li>
<li><a href="#变量作用域">变量作用域</a></li>
<li><a href="#页面获取元素常用方法">页面获取元素常用方法</a></li>
<li><a href="#浏览器的历史记录window-history对象">浏览器的历史记录window.history对象</a></li>
<li><a href="#当前加载页面信息window-location对象">当前加载页面信息window.location对象</a></li>
<li><a href="#浏览器信息navigator对象">浏览器信息navigator对象</a></li>
<li><a href="#日期和时间date对象">日期和时间Date对象</a></li>
<li><a href="#利用math对象简化运算">利用Math对象简化运算</a>
<ul>
<li><a href="#数学常数">数学常数</a></li>
<li><a href="#关键字with">关键字with</a></li>
</ul></li>
<li><a href="#数据类型">数据类型</a>
<ul>
<li><a href="#javascript中的数据类型">JavaScript中的数据类型</a></li>
<li><a href="#非数值-nan">非数值（NaN）</a></li>
<li><a href="#使用parsefloat-和parseint">使用parseFloat()和parseint()</a></li>
<li><a href="#无穷大-infinity">无穷大（Infinity）</a></li>
<li><a href="#字符串方法">字符串方法</a></li>
<li><a href="#布尔值和-非-操作符">布尔值和&rdquo;非&rdquo;操作符</a></li>
<li><a href="#null和undefined">null和undefined</a></li>
</ul></li>
<li><a href="#数组">数组</a>
<ul>
<li><a href="#数组常用">数组常用</a></li>
<li><a href="#多维数组">多维数组</a></li>
</ul></li>
<li><a href="#程序控制">程序控制</a>
<ul>
<li><a href="#比较操作符">比较操作符</a></li>
<li><a href="#常见程序控制">常见程序控制</a></li>
<li><a href="#设置和使用定时器">设置和使用定时器</a></li>
</ul></li>
</ul></li>
<li><a href="#对象">对象</a>
<ul>
<li><a href="#面向对象编程">面向对象编程</a>
<ul>
<li><a href="#对象基础操作">对象基础操作</a>
<ul>
<li><a href="#创建直接实例">创建直接实例</a></li>
<li><a href="#匿名函数">匿名函数</a></li>
<li><a href="#使用构造函数">使用构造函数</a></li>
<li><a href="#对象实例化">对象实例化</a></li>
<li><a href="#拓展对象">拓展对象</a></li>
</ul></li>
<li><a href="#继承">继承</a></li>
<li><a href="#封装">封装</a></li>
<li><a href="#功能检测">功能检测</a></li>
</ul></li>
<li><a href="#遍历dom">遍历DOM</a>
<ul>
<li><a href="#dom常用">DOM常用</a></li>
<li><a href="#创建节点">创建节点</a></li>
</ul></li>
<li><a href="#javascript的json">JavaScript的JSON</a>
<ul>
<li><a href="#json简述">JSON简述</a></li>
<li><a href="#访问json数据">访问JSON数据</a>
<ul>
<li><a href="#使用浏览器对json直接支持">使用浏览器对JSON直接支持</a></li>
</ul></li>
<li><a href="#json的数据序列化">JSON的数据序列化</a></li>
<li><a href="#json数据类型">JSON数据类型</a></li>
<li><a href="#模拟关联数组">模拟关联数组</a></li>
<li><a href="#使用json创建对象">使用JSON创建对象</a>
<ul>
<li><a href="#属性">属性</a></li>
<li><a href="#方法">方法</a></li>
<li><a href="#属性可以是数组">属性可以是数组</a></li>
<li><a href="#json对象换可以包含其他对象">JSON对象换可以包含其他对象</a></li>
</ul></li>
<li><a href="#json的安全性">JSON的安全性</a>
<ul>
<li><a href="#如何确定浏览器内置了json解析器">如何确定浏览器内置了JSON解析器</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#html和css">HTML和CSS</a>
<ul>
<li><a href="#html5和javascript">HTML5和JavaScript</a>
<ul>
<li><a href="#html5的新标签">HTML5的新标签：</a></li>
<li><a href="#html5一些重要的新元素">HTML5一些重要的新元素</a>
<ul>
<li><a href="#video-元素"><code>&lt;video&gt;</code>元素</a></li>
<li><a href="#用-audio-标签播放声音">用<code>&lt;audio&gt;</code>标签播放声音</a></li>
<li><a href="#利用-canvas-在页面上绘图">利用<code>&lt;canvas&gt;</code>在页面上绘图</a></li>
</ul></li>
<li><a href="#html5拖放操作">HTML5拖放操作</a></li>
<li><a href="#本地存储">本地存储</a></li>
<li><a href="#操作本地文件">操作本地文件</a></li>
<li><a href="#html5小结">HTML5小结</a></li>
</ul></li>
<li><a href="#javascript和css">Javascript和CSS</a>
<ul>
<li><a href="#css简介">CSS简介</a>
<ul>
<li><a href="#从内容分离样式">从内容分离样式</a></li>
<li><a href="#css样式声明">CSS样式声明</a></li>
<li><a href="#在哪里保存样式声明">在哪里保存样式声明</a></li>
</ul></li>
<li><a href="#dom的style属性">DOM的style属性</a></li>
<li><a href="#classname访问类">className访问类</a></li>
<li><a href="#dom的stylesheet对象">DOM的styleSheet对象</a>
<ul>
<li><a href="#选择特定样式表">选择特定样式表</a></li>
</ul></li>
<li><a href="#javascript样式表小功能">JavaScript样式表小功能</a></li>
</ul></li>
<li><a href="#css3简介">CSS3简介</a>
<ul>
<li><a href="#特定厂商属性和前缀">特定厂商属性和前缀</a></li>
<li><a href="#css3边框">CSS3边框</a>
<ul>
<li><a href="#创建边框阴影">创建边框阴影</a></li>
<li><a href="#用border-radius属性实现圆角">用border-radius属性实现圆角</a></li>
</ul></li>
<li><a href="#css3背景">CSS3背景</a>
<ul>
<li><a href="#backgroud-size属性">backgroud-size属性</a></li>
<li><a href="#backgroud-origin属性">backgroud-origin属性</a></li>
<li><a href="#多背景图像">多背景图像</a></li>
</ul></li>
<li><a href="#css3渐变">CSS3渐变</a>
<ul>
<li><a href="#线性渐变">线性渐变</a></li>
<li><a href="#放射渐变">放射渐变</a></li>
<li><a href="#其他渐变">其他渐变</a></li>
</ul></li>
<li><a href="#css3文本效果">CSS3文本效果</a>
<ul>
<li><a href="#文本阴影">文本阴影</a></li>
<li><a href="#单词换行">单词换行</a></li>
</ul></li>
<li><a href="#css3过渡-变换和动画">CSS3过渡、变换和动画</a></li>
<li><a href="#在javascript中引用css3属性">在JavaScript中引用CSS3属性</a>
<ul>
<li><a href="#将css3属性名转换到javascript中">将CSS3属性名转换到JavaScript中</a></li>
<li><a href="#dom的getcomputedstyle-方法">DOM的getComputedStyle()方法</a></li>
</ul></li>
<li><a href="#设置带有厂商前缀的css3属性">设置带有厂商前缀的CSS3属性</a></li>
</ul></li>
</ul></li>
</ul>
</nav>

<h1 id="javascript基础">JavaScript基础</h1>

<h2 id="服务器段和客户端编程">服务器段和客户端编程</h2>

<p>给静态页面添加脚本有两种最基本的方式。</p>

<ul>
<li>让Web服务器在把页面发送给用户之前执行脚本。这样的脚本可以确定把哪些内容发送给浏览器以显示给用户，比如从在线商店的数据库获取产品价格，在用户登录到站点的私有区域之前核对用户身份，或是从邮箱获取邮件内容。这些脚本通常运行在Web服务器上，而且是在生成请求的页面并提供给用户之前运行的。因此，我们称之为服务器端脚本（server-side scripting）。</li>
<li>另外一种方式并不是在服务器运行脚本，而是把脚本与页面内容一起发送给用户的浏览器。然后浏览器运行这些脚本，操作已经发送给浏览器的页面内容。这些脚本的主要功能包括动画页面的部分内容，重新安排页面布局，允许用户在页面内拖放元素，验证用户在表单里输入的内容，把用户重定向到其他页面，等等。自然而然, 这些脚本称为客户端脚本（client-side scripting）</li>
</ul>

<p>有一种很酷的方法可以把来自于服务器端脚本的输出组合到客户端脚本,在后面部分介绍Ajax技术时将会学习这种技术.</p>

<h2 id="dom简介">DOM简介</h2>

<p>&ldquo;文档对象模型&rdquo;（Document Object Model, DOM）是对文档及其内容的抽象表示。</p>

<p>每次浏览器要加载和显示页面时，都需要解释（更专业的术语是“解析”）构成页面的HTML源代码。在解析过程中，浏览器建立一个内部模型来表示文档里的内容，这个模型就是DOM。在浏览器渲染页面的可见内容时，就会引用这个模型。可以使用JavaScript来访问和编辑这个DOM的各个部分，从而改变页面的显示内容和用户交互的方式。</p>

<p>在早期，JavaScript只能对Web页面的某些部分进行最基本的访问，比如访问页面里的图像和表单。一个JavaScript程序所包含的语句，可以选择“页面上第二个表单”，或是“名称为registration的表单”。</p>

<p>Web开发人员有时把这种情形称为0级DOM,以便与W3C的1级DOM向下兼容。0级DOM有时也称为BOM（浏览器对象模型）。从0级DOM开始，W3C逐渐扩展和改善了DOM规范。W3C更大的野心是不仅让DOM能够用于Web页面与JavaScript,也能用于任何编程语言和XML。</p>

<ul>
<li>这个层级树的最顶端是浏览器window对象，他是页面的DOM表示中的一切对象的父对象。</li>
</ul>

<p>window对象具有一些子对象，如图所示。图中第一个子对象是document,这也是本书最经常使用的对象。浏览器加载的任何HTML页面都会创建一个document对象，包含全部HTML内容及其他构成页面显示的资源。利用JavaScript以父子对象的形式就可以访 问这些信息。这些对象都具有自己的属性和方法。</p>

<p><img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript3.jpg" alt="JavaScript3" /></p>

<p>图中window对象的其他子对象还有location（包含着当前页面URL的详细信息history（包含浏览器以前访问的页面地址）和navigator（包含浏览器类型、版本和兼容的信息）。后面将会更详细地介绍这些对象，其他地方也会使用它们，但目前我们着重于document对象。</p>

<h2 id="script标签">script标签</h2>

<ul>
<li>使用 <code>&lt;script&gt;&lt;/script&gt;</code> 可以在HTML代码里直接包含Javascript语句。</li>
<li><code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code> 中 <code>type=&quot;text/javascript&quot;</code> 是可选的写法，在HTML5中不需要，在HTML4和XHYML中添加javascript就需要type属性了。</li>
<li><code>&lt;script&gt;&lt;/script&gt;</code> 常放置于 <code>&lt;head&gt;&lt;/head&gt;</code> 标签中，也可以放在 <code>&lt;body&gt;&lt;/body&gt;</code> 等标签中。</li>
<li>把Javascript代码关联到HTML代码中有两种办法，第一种就是把语句直接包含在HTML文件里，第二种更好的办法是把JavaScript放在单独的的文件，然后利用<code>&lt;script&gt;&lt;/script&gt;</code> 元素的 <code>src</code> 属性来指定文件名，即 <code>&lt;script src = 'mycode.js'&gt;&lt;/script&gt;</code> ，从而把这个文件包含在页面里。</li>
</ul>

<p>把JavaScript代码保存到单独的文件夹的好处：</p>

<ul>
<li>当JavaScript代码有更新时，这些更新可以立即作用于使用这个JavaScript文件的页面。这对于JavaScript库是尤为重要的。</li>
<li>HTML页面的代码可以保持简洁，从而提高易读性和可维护性。</li>
<li>可以稍微提高一点性能。浏览器会把包含文件进行缓存，当前页面或其他页面再次需要使用这个文件时，就可以使用一个本地副本了。</li>
</ul>

<p>按照惯例，JavaScript代码文件的名称后缀是.js。但从实际情况来看，代码 NOTE 文件的名称可以使用任何后缀，浏览器都会把其中的内容当作JavaScript来解释。</p>

<p>外部文件中的JavaScript语句不能放到<script>和</script>标签中，也不能使用任何HTML标签，只能是纯粹的JavaScript代码。</p>

<h2 id="函数">函数</h2>

<p>函数内部能够包含对其他函数的调用，可以根据需要进行多重嵌套。</p>

<h1 id="javascript编程">JavaScript编程</h1>

<h2 id="与用户交互的弹窗">与用户交互的弹窗</h2>

<ul>
<li><p>弹出模拟对话框，只有一个按钮。</p>

<pre><code>window.alert(&quot;你好啊！&quot;);
</code></pre></li>

<li><p>弹出模拟对话框，有两个按钮，ok或者cancle,返回一个布尔值。</p>

<pre><code>var answer = confirm(&quot;真的假的？&quot;);
</code></pre></li>

<li><p>弹出模拟对话框，允许用户输入信息，包含两个参数，第二个参数是输入栏的默认信息，如果用户点击的是ok则返回的信息就是输入的字符串，取消获取ESC返回的会是null。</p>

<pre><code>var answer = prompt('你的名字是啥？','刘轲')
</code></pre></li>
</ul>

<h2 id="捕获鼠标事件">捕获鼠标事件</h2>

<ul>
<li>onclick鼠标点击事件。</li>

<li><p>检测鼠标指针和特定元素的位置关系，当鼠标进入页面上被某个元素所占据的区域时，会触发 <code>onMouseOver</code> 事件，鼠标离开这一区域时会触发 <code>onMouseOut</code> 事件。图像翻滚的经典示例：</p>

<pre><code>&lt;img src=&quot;Resources/bajian.jpg&quot; alt=&quot;image 1&quot; onmouseover=&quot;this.src = 'Resources/bajian2.jpg'&quot; onmouseout=&quot;this.src = 'Resources/bajian.jpg'&quot; /&gt;
</code></pre></li>
</ul>

<h2 id="变量作用域">变量作用域</h2>

<p>函数内部声明的变量只存在于函数内部，下面示例比较出乎意料，变量a是全局变量，在函数内也声明了一个变量a，两个变量是不同的。</p>

<pre><code>&lt;body&gt;
    &lt;script&gt;
        var a = 10;
        var b = 10;
        function showVars() {
            var a = 20;
            b = 20;
            return &quot;函数中的a是：&quot; + a + &quot;函数中的b是：&quot; + b;
        }
        var message = showVars();
        alert(&quot;函数返回结果:&quot; + message + &quot;全局变量a现在是：&quot; + a);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>

<p>最终结果：函数中的a是20，全局变量a仍然是10。</p>

<h2 id="页面获取元素常用方法">页面获取元素常用方法</h2>

<p>从HTML中选择某个具有特殊Id的元素的方法：</p>

<pre><code>    var btn = document.getElementById('btnMakeSure');
</code></pre>

<p>它会返回特定Id的页面元素所对应的DOM对象。</p>

<p>innerHTML属性可以读取或者设置页面元素的HTML内容。getElementById和innerHTML属性组合可以获取元素HTML内容，也可以修改其内容。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function TextModify()
        {
            document.getElementById('div1').innerHTML = &quot;页面内容修改成功！&quot;;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;p&gt;这里是一段话！&lt;/p&gt;
    &lt;/div&gt;    
    &lt;input id=&quot;btnModifyWords&quot; type=&quot;button&quot; onclick=TextModify() value=&quot;innerHTML文字修改&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h2 id="浏览器的历史记录window-history对象">浏览器的历史记录window.history对象</h2>

<p>浏览器的历史记录是用window.history对象来表示的，他基本上就是访问过的URL列表。history对象的方法让我们能够使用这个列表，但是不能直接操作这些URL。history对象只有一个对象，就是length，也就是它的长度，表示用户访问过的页面的数量。</p>

<p>history有三个方法，forward()和backward()方法相当于点击浏览器的前进和后退的按钮。可以得到历史列表里面的下一个或者前一个页面。第三个方法go()，它有一个参数，是正的或者负的整数，可以跳到历史列表里面的相对位置，这个方法也可以接收字符串作为参数，找到历史记录列表里面的第一个匹配的URL。</p>

<pre><code>&lt;script&gt;
    function HistoryMofify()
    {
        //页面后退
        history.backword()
        //页面前进
        history.forward ();
        //回退三个页面
        history.go(-3);
        //前进两个页面
        history.go(2);
        //到达历史记录列表里面第一个包含baidu.com的URL
        history.go('baidu.com');
    }
&lt;/script&gt;
</code></pre>

<h2 id="当前加载页面信息window-location对象">当前加载页面信息window.location对象</h2>

<p>location对象包含当前加载页面的信息。页面的URL是由多个部分组成的：[协议]//[主机名]:[端口]/[路径][搜索][hash]。下面是个URL范例： <code>http://www.example.com:8080/tools/display.php?section=435#list</code> .location对象的一系列属性包含了URL各个部分的数据，如图所示：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript5.jpg" alt="JavaScript5" /></p>

<p>利用location有两种方法可以帮助用户导航至新页面。第一种是直接设置对象的href属性,这种方法原始页面还保留在浏览器的历史纪录里，用户可以利用浏览器的back按钮方便的回到以前的页面。
第二种方法使用location的replace()方法是利用新的URL直接替换当前的的页面，会把当前的页面从历史记录里面删除。</p>

<pre><code>    location.href= 'www.newpage.com';
    location.replace('www.newpage.com')`;
</code></pre>

<p>可以用location对象的reload()方法在浏览器里面重新加载当前页面，如果方法内有参数则会确保从服务器端重新获取页面数据：</p>

<pre><code>    location.reload();
    location.reload(true);
</code></pre>

<h2 id="浏览器信息navigator对象">浏览器信息navigator对象</h2>

<p>navigator对象包含了浏览器程序本身的数据,展示如图所示：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript6.jpg" alt="JavaScript6" /></p>

<h2 id="日期和时间date对象">日期和时间Date对象</h2>

<p>新建一个包含日期和时间信息的Date对象的最简单方法是：</p>

<pre><code>    var mydate = new Date();
</code></pre>

<p>mydate就是一个Date对象，其中包含了创建对象的日期和时间信息。JavaScript具有很多方法用于获取设置和编辑Date对象中的数据，展示如图：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript7.jpg" alt="JavaScript7" /></p>

<p>给Date()语句指定参数，可以创建任意指定日期和时间的Date()对象，方式如图：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript8.jpg" alt="JavaScript8" />
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript9.jpg" alt="JavaScript9" /></p>

<p>设置和编辑日期与时间:</p>

<p><img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript10.jpg" alt="JavaScript" /></p>

<h2 id="利用math对象简化运算">利用Math对象简化运算</h2>

<p>JavaScript中的Math方法：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript11.jpg" alt="JavaScript11" /></p>

<p>特别说下随机数，利用 <code>Math.random()</code> 产生的是0到1之间随机数，要想获取0到100的随机数需要乘以100 <code>Math.random() * 100</code> 。</p>

<h3 id="数学常数">数学常数</h3>

<p>很多常用的数学常熟都以Math的属性的方式出现，如图所示：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript12.jpg" alt="JavaScript12" /></p>

<h3 id="关键字with">关键字with</h3>

<p>任何对象都可以使用with，但是Math对象是最适合用来示范的。通过使用with，可以减少键盘的输入。</p>

<p>关键字with以对象为参数，然后是一对花括号，其中包含着代码块。代码块里的语句在调用特定对象方法时可以不必指定这个对象，因为JavaScript会假定这些方法是属于参数的那个对象的。范例：</p>

<pre><code>&lt;script&gt;
    function withDemo()
    {
        with (Math) {
            var myRand = random();
            var bigger = max(2, 6, 9);
            var height = round(72.38);
        }
    }
&lt;/script&gt;
</code></pre>

<h2 id="数据类型">数据类型</h2>

<h3 id="javascript中的数据类型">JavaScript中的数据类型</h3>

<p><img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript13.jpg" alt="JavaScript13" /></p>

<h3 id="非数值-nan">非数值（NaN）</h3>

<p>当脚本试图把一些非数值数据当作数值处理，却无法得到数值时，其返回值就是NaN。利用isNaN()函数可以检测非数值：</p>

<pre><code>isNaN(3); //返回false
isNaN('test'); //返回true
</code></pre>

<h3 id="使用parsefloat-和parseint">使用parseFloat()和parseint()</h3>

<p>parseFloat()函数解析字符串，并返回一个浮点数。，如果被解析的字符串的首字符时一个数字，函数会一直解析到数组结束，然后返回一个数值而不是字符串：</p>

<pre><code>parseFloat(&quot;2.14&quot;); //返回2.14
parseFloat(&quot;35 test&quot;); //返回35
parseFloat(&quot;test 35&quot;) = 35; //返回NaN
</code></pre>

<p>parseint()的功能类似,但是其返回的时整数和NaN，该函数可以加第二个参数，用于指定数值的基，从而返回二进制等其他进制的数值所对应的十进位制数值。</p>

<pre><code>parseint(25.8); 返回25
parseint(&quot;34px&quot;，10); 返回34
parseint(&quot;1110&quot;,2); 返回14
parseint(&quot;Hello&quot;); 返回NaN
</code></pre>

<h3 id="无穷大-infinity">无穷大（Infinity）</h3>

<p>超过Javascript能表示的最大数值，就是无穷大，在大多数的JavaScript版本中最大的数值是正或者负的2的53次方，还有一个表示负的无穷大的关键字字面值：-infinity。利用isFinite()函数可以判断一个数值是否是无穷大。他会把参数转换为数值，如果得到的数值是NaN、正无穷大（Infinity）、负无穷大（-Infinity），函数返回false，其他返回true。</p>

<pre><code>isFinite(32); //返回true
isFinite(&quot;hello&quot;); //返回false
</code></pre>

<h3 id="字符串方法">字符串方法</h3>

<p>比较重要的字符串方法：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript14.jpg" alt="JavaScript14" /></p>

<h3 id="布尔值和-非-操作符">布尔值和&rdquo;非&rdquo;操作符</h3>

<p>布尔值做运算的话 <code>true * 1 = 1</code> <code>false * 1 = 0</code> 即true会换算为1，false会换算为0。下面这些值在JavaScript中都当作false处理</p>

<ul>
<li>布尔值false</li>
<li>未定义（undefined）</li>
<li>null</li>
<li>0</li>
<li>NaN</li>
<li>&rdquo; &ldquo;(空字符串)</li>
</ul>

<p>当字符!位于布尔变量之前时，Javascript把它解释为非，也就是相反的值。</p>

<h3 id="null和undefined">null和undefined</h3>

<p>当我们想让变量具有有效值，却又不是任何数值时，就把null赋值给变量，对数值来说null相当于0，对字符串来说null相当于字符串&rdquo;&ldquo;，对布尔值来说相当于false。与null不同的时undefined不是关键字，而是预定义的全局变量，当某个变量已经在语句里使用了，却没有赋给任何值时，它的值不是null而时undefined，表示Javascript不能识别它。</p>

<h2 id="数组">数组</h2>

<h3 id="数组常用">数组常用</h3>

<p>创建新数组的方法：</p>

<pre><code>var myArray = new Array();
var myArray = [];
</code></pre>

<p>在创建数组时可以同时加载数据：</p>

<pre><code>var myArray = ['Monday','Tuesday'];
</code></pre>

<p>或者在数组创建以后再添加：</p>

<pre><code>var myArray = [];
myArray[] = 'Monday';
myArray[] = 'Tuesday';
</code></pre>

<p>下图时数组常用的一些方法：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript15.jpg" alt="JavaScript15" /></p>

<p>join()方法还可以有一个字符串参数，他会作为分隔符插入到最终的字符串里面：</p>

<pre><code>var joinStr = myArray.join(&quot;-&quot;); // 返回Monday-Tuesday
</code></pre>

<p>tostring()方法还可以说时Join()方法的一个特例，它返回由数组元素组成的字符串，用逗号分隔每个元素。</p>

<pre><code>var tostringStr = myArray.tostring(); // 返回Monday,Tuesday
</code></pre>

<p>slice()方法用来提取子集，用这个方法，在参数中指定开始的索引和要提取的数量：</p>

<pre><code>var sliceStr = myArray.slice(1,1); // 返回Monday
</code></pre>

<p>splice()方法可以在数组删除指定位置元素后再添加元素。</p>

<pre><code>array.splice(index,howMany,[new elements);
</code></pre>

<p>第一个参数指定在数组的什么位置操作，第二个参数说明要删除多少个元素(设置为0则不删除)，第三个参数是可选的，是要插入的新元素列表。返回的参数是删除的元素</p>

<pre><code>var myArray = ['Monday','Tuesday'];
myArray.splice(2,1,&quot;friday&quot;) //结果是['Monday','friday']，返回Tuesday。
</code></pre>

<h3 id="多维数组">多维数组</h3>

<p>多维数组很少用，这个是示例：</p>

<pre><code>var myArray = [[1,2],[3,4],[5,6]];
alert(myArray[1][0]); //结果是3
</code></pre>

<h2 id="程序控制">程序控制</h2>

<h3 id="比较操作符">比较操作符</h3>

<p>比较操作符，不常见的有 <code>===</code> 即值和类型都相等,具体如下：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript16.jpg" alt="JavaScript16" /></p>

<h3 id="常见程序控制">常见程序控制</h3>

<p>JavaScript中常见的程序控制有： <code>if</code> <code>if else</code> <code>switch</code> ,循环和控制结构： <code>while</code> <code>do...while</code> <code>for</code> <code>for in</code> 。不常见的有 <code>for in</code> ， <code>for in</code> 是一种特殊循环，用于在对象的属性里进行循环，类似编程中的foreach。</p>

<h3 id="设置和使用定时器">设置和使用定时器</h3>

<p>很多情况下我们需要   让程序延迟一会儿再执行JavaScript代码，例如：想让一条消息显示一会儿，然后再将其删除。JavaScript提供了两个有用的方法，分别是setTimeout()和setInterval().
setTimeout(action,delay)方法在第二个参数所指定的毫秒之后，调用作为第一个参数传入的函数（或者计算该表达式）。setTimeout()方法返回一个值，如果想取消定时器的函数，可以通过将该返回值传入给clearTimeout()方法来引用它。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function hide(elementId) {
            document.getElementById(elementId).innerHTML = &quot;定时任务触发成功！&quot;;
        }

        window.onload = function () {
            var time1 = setTimeout(hide('id1'), 3000);
            clearTimeout(time1);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;id1&quot;&gt;
            我一会儿会消失~~~
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>setInterval(action,delay)方法的工作方式和setTimeout(action,delay)的差不多，不过setInterval()是重复执行，在两次执行之间，延迟第二个参数指定的毫秒时间。同样可以用返回值调用clearInterval()方法以停止该定时器。</p>

<h1 id="对象">对象</h1>

<h2 id="面向对象编程">面向对象编程</h2>

<p>面向对象编程的优点：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript17.jpg" alt="JavaScript17" /></p>

<h3 id="对象基础操作">对象基础操作</h3>

<h4 id="创建直接实例">创建直接实例</h4>

<p>Javascript有一个内置的对象Object，利用它可以创建一个空白的对象，这个时候它没有任何属性和方法，我们给它添加属性添加方法：</p>

<pre><code>&lt;script&gt;
    //新建对象
    myNewObject = new Object();
    //增加属性
    myNewObject.info = &quot;我是一个新的对象！&quot;;
    //增加方法
    function myFunc() {
        //this指向函数的父对象，即调用函数的对象，不是用对象而是直接调用的时候，
        //this指代window，因为window没有info对象，所以会触发异常报错。
        alert(this.info);
    }
    myNewObject.showInfo = myFunc;
    //调用方法
    myNewObject.showInfo();
&lt;/script&gt;
</code></pre>

<h4 id="匿名函数">匿名函数</h4>

<p>还可以用另一种方法来给对象添加方法，因它不需要函数名称，所以被称为匿名方法：</p>

<pre><code>&lt;script&gt;
    //新建对象
    myNewObject = new Object();
    //增加属性
    myNewObject.info = &quot;我是一个新的对象！&quot;;
    //增加方法

    myNewObject.showInfo = function () {
        //this指向函数的父对象，即调用函数的对象，不是用对象而是直接调用的时候，
        //this指代window，因为window没有info对象，所以会触发异常报错。
        alert(this.info);
    }
    //调用方法
    myNewObject.showInfo();
&lt;/script&gt;
</code></pre>

<h4 id="使用构造函数">使用构造函数</h4>

<p>如果创建多个函数，上面的方法就需要重复操作了，更好的方法是使用对象构造函数来创建模板，方便多次实例化，同时它可以附带多个参数，进行定制对象。</p>

<pre><code>&lt;script&gt;
    function myObjectType(perserName) {
        //增加属性
        this.info = &quot;我是一个新的对象！&quot;;
        this.name = perserName;
        //增加方法
        this.showInfo = function () {
            alert(this.info);
        };
        this.setInfo = function (newInfo) {
            this.info = newInfo;//覆盖Info属性
        };
    }
&lt;/script&gt;
</code></pre>

<h4 id="对象实例化">对象实例化</h4>

<p>现在可以创建多个含有这个myObjectType函数定义的属性和方法，实例化这个对象很简单：</p>

<pre><code>var myNewObject = new myObjectType(&quot;tom&quot;);
var myNewObject2 = new myObjectType(&quot;marry&quot;);//可以方便的创建多个
</code></pre>

<h4 id="拓展对象">拓展对象</h4>

<p>我们可以用关键字prototype，来迅速给已经实例化的对象添加属性和方法然后就可以用于全部实例。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function myObjectType(perserName) {
            //增加属性
            this.info = &quot;我是一个新的对象！&quot;;
            this.name = perserName;
            //增加方法
            this.showInfo = function () {
                alert(this.info);
            };
            this.setInfo = function (newInfo) {
                this.info = newInfo;//覆盖Info属性
            };
        }

        myNewObject = new myObjectType(&quot;Marry&quot;);
        myObjectType.prototype.sayHello = function () {
            alert(&quot;我是&quot; + this.name + &quot;，你好啊！&quot;);
        }
        myNewObject2 = new myObjectType(&quot;Jack&quot;);
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;input type=&quot;button&quot; value=&quot;对象测试&quot; onclick=&quot;myNewObject.sayHello()&quot; /&gt;    
    &lt;input type=&quot;button&quot; value=&quot;对象测试2&quot; onclick=&quot;myNewObject2.sayHello()&quot; /&gt;    
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="继承">继承</h3>

<p>JavaScript模拟实现继承的方法也是使用关键字prototype，因为prototype可以添加新的方法和属性，所以我们可以用它把已有的构造函数的方法和属性都添加到新的对象。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function pet() {
            this.animal = &quot;&quot;;
            this.name = &quot;&quot;;
            //增加方法
            this.setAnimail = function (newAnimail) {
                this.animal = newAnimail;
            };
            this.setName = function (newName) {
                this.Name = newName;//覆盖Info属性
            };
        }

        var mycat = new pet();
        mycat.setAnimail = &quot;猫&quot;;
        mycat.setName = &quot;Tony&quot;;

        function Dog() {
            this.breed = &quot;&quot;;
            this.setBreed = function (newBreed) {
                this.breed = newBreed;
            }
        }

        Dog.prototype = new pet();

        var myDog = new Dog();
        myDog.setAnimail = &quot;狗&quot;;
        myDog.setName = &quot;Lily&quot;;
        myDog.setBreed = &quot;藏獒&quot;;

        alert(&quot;我的宠物是&quot; + myDog.animal + &quot;，它的名字是&quot; + myDog.name + &quot;，它的品种是&quot; + myDog.breed);

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p><strong>关键字prototype还可以拓展Javascript内置的属性。</strong></p>

<h3 id="封装">封装</h3>

<p>封装是面向对象编程的一种能力，表示把数据和指令隐藏到对象内部。对于Javascript来说，在构造函数内部声明的变量和函数只能在内部使用，他们对于外部是不可见的。如果没有用关键字this把变量和函数注册为属性和方法，它们就不能从函数外部调用。</p>

<pre><code>function Box(width,length,height){
    function volume(a,b,c){
    return a * b * c;
    }
    this.boxVolume = volume(width,length,height);
}

var crete = new Box(5,4,3);
alert(&quot;体积=&quot; + crete.boxVolume); //正常工作
alert(&quot;体积=&quot; + volume(5,4,3)); //不能正常工作
</code></pre>

<h3 id="功能检测">功能检测</h3>

<p>在JavaScript中检测浏览器是否支持代码所需的功能可以用尝试使用对方、方法或者属性，然后检测JavaScript返回的值。以下例子是检测是否支持：</p>

<pre><code>&lt;script&gt;
    if(document.getElementById)
    {
        //可以用getElementById方法
    }
    else
    {
        //不可以用getElementById方法
    }
&lt;/script&gt;
</code></pre>

<p>使用typeof操作符检测某个JavaScript函数是否存在：</p>

<pre><code>&lt;script&gt;        
    if (typeof document.getElementById == 'function')
    {
        //可以用getElementById方法
    }
    else
    {
        //不可以用getElementById方法
    }
&lt;/script&gt;
</code></pre>

<p>typeof可能返回的值如图：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript18.jpg" alt="JavaScript18" /></p>

<p>使用这种技术不禁可以检测DOM和内置对象、方法和属性的存在，还可以检测脚本中创建的对象、方法和属性。</p>

<h2 id="遍历dom">遍历DOM</h2>

<h3 id="dom常用">DOM常用</h3>

<p>W3C“文档对象模型”(DOM)是一种由父子关系组成的层次树形结构，构成当前Web页面的模型。DOM层级结构中最顶端的是window对象，而document对象是它的子对象之一。每个节点都有一个关联的数值，保存在属性noteType中值含义如下：</p>

<table>
<thead>
<tr>
<th align="center">noteType值</th>
<th align="center">节点类型</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1</td>
<td align="center">元素</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">属性</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">文本(包含空白)</td>
</tr>

<tr>
<td align="center">4</td>
<td align="center">CDATA区域</td>
</tr>

<tr>
<td align="center">5</td>
<td align="center">实体引用</td>
</tr>

<tr>
<td align="center">6</td>
<td align="center">实体</td>
</tr>

<tr>
<td align="center">7</td>
<td align="center">执行指令</td>
</tr>

<tr>
<td align="center">8</td>
<td align="center">HTML注释</td>
</tr>

<tr>
<td align="center">9</td>
<td align="center">文档</td>
</tr>

<tr>
<td align="center">10</td>
<td align="center">文档类型(DTD)</td>
</tr>

<tr>
<td align="center">11</td>
<td align="center">文档片段</td>
</tr>

<tr>
<td align="center">12</td>
<td align="center">标签</td>
</tr>
</tbody>
</table>

<p>每个节点都有一个childNodes属性。这个类似数组的属性包含了当前节点全部子节点的集合，被称作节点列表(nodeList)，其中的项目以数值来索引，可以像访问数组元素一样访问集合里的项目，也可以遍历这个数组，但是有些数组方法不可使用，比如push()和pop()。节点列表是一个动态集合，这表示集合的任何改变都会立即反映到列表。</p>

<p>使用firstChild和lastChild可以分别访问节点列表的第一个和最后一个元素，而parentNode属性保存节点的父节点。previousSibling和nextSibling属性分别返回节点的前一个和后一个兄弟节点，如果节点不存在则返回null。</p>

<p>DOM节点的nodeValue属性返回保存在节点里的值，常用来返回文本节点里的内容。nodeName属性以字符串形式返回节点的名称，，这个属性是只读的。当nodeName返回元素名称时并不包括HTML源代码里面使用的尖括号。以下是NodeName可能返回的值：</p>

<table>
<thead>
<tr>
<th align="center">notype</th>
<th align="center">节点类型</th>
<th align="center">nodeName值</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">1</td>
<td align="center">元素</td>
<td align="center">元素(标签)名称</td>
</tr>

<tr>
<td align="center">2</td>
<td align="center">属性</td>
<td align="center">属性名称</td>
</tr>

<tr>
<td align="center">3</td>
<td align="center">文本</td>
<td align="center">字符串&rdquo;#text&rdquo;</td>
</tr>
</tbody>
</table>

<p>document的方法getElementsByTagName可以获得特定的全部标签，将它们放在一个数组里面，它需要的参数是标签的名称。</p>

<p>使用getAttribute()方法可以获取元素的属性值，如果尝试访问不存在的属性，这个方法会返回null，由于JavaScript把null解释为false，利用这个特性可以检查一个元素节点是否定义了特定的属性。</p>

<pre><code>if(myNode.getAttribut(&quot;title&quot;))
{
    //执行操作
}
</code></pre>

<h3 id="创建节点">创建节点</h3>

<p>给DOM树添加新节点需要两个步骤：</p>

<ul>
<li>首先是创建一个新节点。节点创建以后处于某种“不确定的状态”,它的确存在，但不属于DOM树的任何位置，也就不会出现在浏览器窗口里了。</li>
<li>接下来把节点添加到DOM树的指定位置，它就成为页面的组成部分了。</li>
</ul>

<p>createElement可以用来创建任意的标准Html元素，比如段落、区间、表格、列表等</p>

<pre><code>var newDiv = document.createElement(&quot;div&quot;);
</code></pre>

<p>页面很多的HTML元素需要文本形式的内容，这就需要使用CreateTextNode()方法，它的参数是元素需要的文本内容：</p>

<pre><code>var newTextNode = document.createTestNode(&quot;这是一些文字！&quot;);
</code></pre>

<p>为避免重复劳动，如果新建节点和已有的节点比较类似就可以使用cloneNode()来创建节点，cloneNode()接收一个单个的布尔型参数，当参数为true时表示不仅要复制节点，还要复制它的全部子节点。</p>

<p>前面创建的节点不在DOM树的任何位置，需要将新增的节点放置在DOM树里。</p>

<p>把新节点添加到DOM树的最简单的方法是用appendChild()方法把它作为已有节点的一个子节点，这里只需要获取它的父节点。appendChild()不仅可以用于文本节点，也可以用于各种类型的节点。</p>

<pre><code>var newText = document.createTextNode(&quot;这里是一些文字&quot;);
var myDIv = document.getElementById(&quot;div1&quot;);
myDIv.appendChild(newText);
</code></pre>

<p>appendChild()总是把新的节点添加到子节点列表的末尾，而insertBefore()方法可以指定一个子节点，然后把新节点插入到它的前面。这个方法的参数有两个：要插入的新节点和要放在哪个节点前面。</p>

<pre><code>var newpara = document.createElement(&quot;P&quot;);
var myDIv = document.getElementById(&quot;div1&quot;);
var para2 = document.getElementById(&quot;para2&quot;);
myDIv.insertBefore(newpara, para2);
</code></pre>

<p>replaceChild()方法可以把父节点现有的元素替换为另一个节点。它有两个参数：一个是新的节点，另一个是要被替换的现有节点。</p>

<pre><code>var newpara = document.createElement(&quot;P&quot;);
var myDIv = document.getElementById(&quot;div1&quot;);
var para2 = document.getElementById(&quot;para2&quot;);
myDIv.replaceChild(newpara, para2);
</code></pre>

<p>removeChild()方法专门用于从DOM树里删除子节点，参数是被删除的节点。方法的返回值是被删除节点的一个引用，在需要时可以利用它对被删除的节点实现进一步操作。</p>

<pre><code>var myDIv = document.getElementById(&quot;div1&quot;);
var para2 = document.getElementById(&quot;para2&quot;);
var oldChild = myDIv.removeChild(para2);
</code></pre>

<p>编辑元素属性，前面介绍过使用getAttribute()读取元素属性，可以用setAttribute()方法为元素节点创建属性并赋值。它有两个参数，一个是要添加的属性，一个是属性值。</p>

<p>在某些情况下我们需要在浏览器加载的页面随时加载Javascript代码，实现方法如下</p>

<pre><code>var scr = document.createElement(&quot;script&quot;);
src.setAttribute(&quot;src&quot;, &quot;newScript.js&quot;);
document.head.appendChild(scr);
</code></pre>

<p>注意，如果以这种方式加载的JavaScript源文件在文件完成加载前，页面不能使用其中包含的代码。在使用这些额外的代码前最好进行校验。几乎现在的浏览器在脚本完成下载之后都会触发一个onload()事件，与window.onload事件的工作方式类似，不过后者是在页面完成加载时触发，而前者是在外部资源（本例是JavaScript源文件）完成下载应可以使用时触发。</p>

<pre><code>var scr = document.createElement(&quot;script&quot;);
src.setAttribute(&quot;src&quot;, &quot;newScript.js&quot;);
document.head.appendChild(scr);
scr.onload = function () {
    //新代码加载完成后要执行的逻辑
}
</code></pre>

<p>动态创建菜单的范例：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript19.jpg" alt="JavaScript19" />
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript20.jpg" alt="JavaScript20" />
具体的menu.js如下：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript21.jpg" alt="JavaScript20" />
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript22.jpg" alt="JavaScript20" /></p>

<h2 id="javascript的json">JavaScript的JSON</h2>

<h3 id="json简述">JSON简述</h3>

<p>JSON是JavaScript object notation的缩写，JSON数据的表示方式是一系列成对的参数与值，参数和值由冒号分隔，每对之间以逗号分隔。</p>

<pre><code>&quot;param1&quot;:&quot;value1&quot;,&quot;param2&quot;:&quot;value2&quot;,&quot;param3&quot;:&quot;value3&quot;
</code></pre>

<p>最终这些用花括号包围起来，构成表示数据的JSON对象：</p>

<pre><code>var jsonObject = {
        &quot;param1&quot;: &quot;value1&quot;,
        &quot;param2&quot;: &quot;value2&quot;,
        &quot;param3&quot;: &quot;value3&quot;
    }
</code></pre>

<p>对象jsonObject的定义使用标准JavaScript表示法的子集，这只是有效的JavaScript代码的一小部分。
使用JSON表示法编写的对象也具有属性和方法，能够利用句号表示法进行访问：</p>

<pre><code>alert(jsonObject.param1); //显示value1
</code></pre>

<p>更好的是json是一种以字符串格式实现数据交换的通用语法，不仅仅是对象，任何能够以一系列&rdquo;参数&rdquo;:&ldquo;值”对表示的数据都能够以Json表示法来表示。前面提到的&rdquo;序列化&rdquo;过程可以方便的把json对象转换为字符串，而序列化的数据便于在网络环境中进行存储和传输。</p>

<p>json和xml的区别：作为一种通用的数据交换方法，JSON的用途有些类似于XML，但是它更易于阅读和理解。另外大型的XML文件解析过程较慢，而JSON提供的是JSON对象，随时可以使用。</p>

<p>JSON具有一些重要的优点，从而在近期获得了巨大的发展动力。</p>

<ul>
<li>对人类和计算机都很易读。</li>
<li>概念很简单，JSON就是一系列用花括号包含的一系列&rdquo;参数&rdquo;:&ldquo;值&rdquo;对。</li>
<li>基本上是其义自明的。</li>
<li>能够快速创建和解析。</li>
<li>它是JavaScript的一个子集，不需要特殊的解释程序和额外的软件包。</li>
</ul>

<h3 id="访问json数据">访问JSON数据</h3>

<p>直到最近，才有一些浏览器可以直接支持JSON，但是由于json是JavaScript的一个子集，我们可以使用JavaScript的函数eval()把JSON转换为JavaScript对象。</p>

<p>eval()会计算或运行作为参数传递的内容，如果参数是表达式，eval()会计算它的值，如果参数包含一个或者多个JavaScript语句，eval()会执行这些语句。示例如下：</p>

<pre><code>var x = eval(4 * 3); //x = 12
eval(&quot;a= 1;b=2; docunment.write(a+b);&quot;); //向页面写入3
</code></pre>

<p>eval()函数使用JavaScript解释程序解析JSON文本来生成JavaScript对象，然后就可以在对象里使用这个对象了：</p>

<pre><code>var user = {
    &quot;userName&quot;: &quot;Sean&quot;,
    &quot;location&quot;: &quot;China&quot;,
    &quot;height&quot;: &quot;1.85&quot;
}
var myObject = eval('(' + user + ')');
alert(myObject.userName);
</code></pre>

<p><strong>注意：字符串必须像这样包含在括号里，以避免造成含义不明确的JavaScript语法。</strong></p>

<h4 id="使用浏览器对json直接支持">使用浏览器对JSON直接支持</h4>

<p>最新的浏览器都对JSON提供直接支持，而不需要使用eval()函数，这些浏览器包括：</p>

<ul>
<li>FireFix(Mozilla) 3.5+</li>
<li>IE 8+</li>
<li>Goole Chrome</li>
<li>Opera 10+</li>
<li>Safari 4+</li>
</ul>

<p>浏览器会创建一个名为JSON的Javascript对象来管理JSON的编码和解码。这个对象有两个方法stringify()和parse()。JSON.parse()方法用于解释JSON字符串，它接受一个字符串作为参数，解析它，创建一个对象并且根据字符串中找到的&rdquo;参数&rdquo;:&ldquo;值&rdquo;对设置对象的参数：</p>

<pre><code>window.onload = function() {
        var user = '{&quot;userName&quot;: &quot;Sean&quot;,&quot;location&quot;: &quot;China&quot;,&quot;height&quot;: &quot;1.85&quot; }';            
        var myObject = JSON.parse(user);
        var out = &quot;&quot;;
        for (i in myObject) {
            out += i + &quot; = &quot; + myObject[i] + &quot;\n&quot;;
        }            
        alert(out);
    }
</code></pre>

<p>结果如图所示：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript23.jpg" alt="JavaScript23" /></p>

<h3 id="json的数据序列化">JSON的数据序列化</h3>

<p>在数据存储和转化时，序列化是指把数据转换为便于通过网络进行存储和传输的形式，稍后再恢复为原始的格式，JSON选择字符串作为序列化数据的格式。在支持JSON的浏览器里，我们只需要简单的使用JSON.stringify()方法。</p>

<pre><code>var dan = new Object();
dan.height = 1.86;
dan.age = 28;
alert(JSON.stringify(dan));
</code></pre>

<h3 id="json数据类型">JSON数据类型</h3>

<p>每个&rdquo;参数&rdquo;:&ldquo;值&rdquo;对里的参数部分必须遵循一些简单的语法规则：</p>

<ul>
<li>不能是JavaScript保留的关键字</li>
<li>不能以数字开头</li>
<li>除下划线和美元符号外，不能包含任何特殊字符。</li>
</ul>

<p>JSON的对象的值可以是如下的一些数据类型：</p>

<ul>
<li>数值</li>
<li>字符串</li>
<li>布尔值</li>
<li>数组</li>
<li>对象</li>
<li>null(空)</li>
</ul>

<p>javascript有一些数据类型不属于JSON标准，包括Date、Error、Math、和function。这些数据必须用其他数据格式来表示，使用遵循相同编码和解码规则的其他数据格式来进行处理。</p>

<h3 id="模拟关联数组">模拟关联数组</h3>

<p>JavaScript的数组里的元素具有唯一的数值索引：</p>

<pre><code>var myArray = [];
myArray[0] = 'Monday';
</code></pre>

<p>在其他编程方式中可以使用文本形式的索引,但是JavaScript并不支持：</p>

<pre><code>myArray['startDay'] = 'Monday';
</code></pre>

<p>然而利用对象可以方便的模拟这种行为，比如利用JSON表示法可以让上述代码更易于阅读和理解：</p>

<pre><code>var conference = {
    &quot;startDay&quot;: &quot;Monday&quot;,
    &quot;nextDay&quot;: &quot;Tuesday&quot;,
    &quot;endDay&quot;: &quot;Wednesday&quot;
};
alert(conference[&quot;startDay&quot;]);
</code></pre>

<p>在Javascript中Object.property和Object[&ldquo;property&rdquo;]是相同的语法。虽然看上去挺像字符串索引的数组，但是对它进行遍历，会得到对象的三个属性和它包含的全部方法。</p>

<h3 id="使用json创建对象">使用JSON创建对象</h3>

<h4 id="属性">属性</h4>

<p>于创建数组不同，我们在用JSON表示法表示对象时，是把对象包括在花括号里，而不是方括号里，并且以&rdquo;参数&rdquo;:&ldquo;值&rdquo;对的方式列出属性：</p>

<pre><code>var user = {&quot;userName&quot;: &quot;Sean&quot;,&quot;location&quot;: &quot;China&quot;,&quot;height&quot;: &quot;1.85&quot; };
</code></pre>

<p>之后就可以用常见的形式访问对象的属性：</p>

<pre><code>var name = user.userName; //变量name包含的值是Sean
</code></pre>

<h4 id="方法">方法</h4>

<p>同样使用上面的形式，在对象定义之中利用匿名函数就可以给对象添加方法。</p>

<pre><code>var user = {
    &quot;userName&quot;: &quot;Sean&quot;,
    &quot;location&quot;: &quot;China&quot;,
    &quot;height&quot;: &quot;1.85&quot;,
    &quot;setName&quot;: function (newName) {
        this.userName = newName;
    };

var userName = prompt(&quot;请输入一个新的用户名&quot;);
user.setName(userName);
</code></pre>

<p><strong>注意：在JavaScript环境中使用这种方式添加方法是可以的，但当JSON作为通用数据交换格式时，不能这样使用。在支持JSON的浏览器里面，以这种形式声明的函数会直接解析错误，但eval()函数仍然可以工作。当然如果实例化的脚本只是在自己的脚本里使用，还是可以这样使用的。这是考虑到JSON的安全性。</strong></p>

<h4 id="属性可以是数组">属性可以是数组</h4>

<p>属性可以是数组，示例如下：</p>

<pre><code>var user = {
    &quot;userName&quot;: &quot;Sean&quot;,
    &quot;location&quot;: &quot;China&quot;,
    &quot;height&quot;: &quot;1.85&quot;,
    &quot;hasBooks&quot;:[&quot;小人国&quot;,&quot;三国志&quot;,&quot;钢炼&quot;] 
};
var book = user.hasBooks[0];
alert(book);
</code></pre>

<h4 id="json对象换可以包含其他对象">JSON对象换可以包含其他对象</h4>

<p>JSON对象换可以包含其他对象，通过把数组元素本身设置为JSON编码的对象，我们就可以用句点表示法访问它们。在下面的示例中，属性booklist的值是json对象组成的数组，每个JSON对象分别用于保存图书的标题和作者信息。在获得图书列表后可以很方便的获取标题和作者信息属性。</p>

<pre><code>var bookListObject = {
    &quot;bookList&quot;: [{ &quot;title&quot;: &quot;小人国&quot;, &quot;author&quot;: &quot;乔纳森·斯威夫特&quot; },
        { &quot;title&quot;: &quot;三国志&quot;, &quot;author&quot;: &quot;陈寿&quot; }
    ]
};
alert(bookListObject.bookList[1].author);//显示第二本书的作者-陈寿
</code></pre>

<h3 id="json的安全性">JSON的安全性</h3>

<p>使用JavaScript的eval()函数可以执行任何JavaScript命令，这可能会导致潜在的安全问题，特别是处理来源不明的JSON数据时。更安全的方法是使用浏览器内置的JSON解析器把JSON字符串转化为Javascript对象，它只识别JSON文本，而且不会执行脚本命令。同时内置的JSON解析器的速度也比eval()函数快一些，基本较新的浏览器都内置了JSON解析器。</p>

<h4 id="如何确定浏览器内置了json解析器">如何确定浏览器内置了JSON解析器</h4>

<p>确保脚本中没有自己定义的名为JSON的对象，然后利用typeof操作符可以判断是否存在JSON对象：</p>

<pre><code>if(typeof JSON == 'object')
{
    alert(&quot;浏览器内置了JSON解析器！&quot;);
}
else
{
    alert(&quot;浏览器没有内置JSON解析器！&quot;);
}
</code></pre>

<h1 id="html和css">HTML和CSS</h1>

<h2 id="html5和javascript">HTML5和JavaScript</h2>

<h3 id="html5的新标签">HTML5的新标签：</h3>

<p>即使是组织很好的HTML页面，对其代码的阅读和理解都会比想象中的困难得多，主要原因是标签本身包含的语义信息很少。像边栏、标题和页脚、导航元素这些页面页面组成部分都被包含在像div这样的通用元素里，只能根据开发人员设置的Id和类名加以区分。</p>

<p>HTML5添加的新元素更容易识别，也更明确其中的内容。下表列出了一些新标签：</p>

<table>
<thead>
<tr>
<th align="center">标签</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><code>&lt;section&gt;</code></td>
<td align="left">定义页面的区域</td>
</tr>

<tr>
<td align="center"><code>&lt;header&gt;</code></td>
<td align="left">页面标题</td>
</tr>

<tr>
<td align="center"><code>&lt;footer&gt;</code></td>
<td align="left">页面页脚</td>
</tr>

<tr>
<td align="center"><code>&lt;nav&gt;</code></td>
<td align="left">页面导航元素</td>
</tr>

<tr>
<td align="center"><code>&lt;article&gt;</code></td>
<td align="left">页面的文章或主要内容</td>
</tr>

<tr>
<td align="center"><code>&lt;aside&gt;</code></td>
<td align="left">页面的附加内容，比如边栏</td>
</tr>

<tr>
<td align="center"><code>&lt;figure&gt;</code></td>
<td align="left">文章的配图</td>
</tr>

<tr>
<td align="center"><code>&lt;figcaption&gt;</code></td>
<td align="left"><code>&lt;figure&gt;</code>元素的标题</td>
</tr>

<tr>
<td align="center"><code>&lt;summary&gt;</code></td>
<td align="left"><code>&lt;details&gt;</code>元素的可视标题</td>
</tr>
</tbody>
</table>

<h3 id="html5一些重要的新元素">HTML5一些重要的新元素</h3>

<h4 id="video-元素"><code>&lt;video&gt;</code>元素</h4>

<p>HTML5提供了一个崭新的<code>&lt;video&gt;</code>元素，其目标是嵌入任意一种视频格式。使用新的<code>&lt;video&gt;</code>标签可以像下面这样实现QuickTime视频：</p>

<pre><code>&lt;video src=&quot;Resources/video.mp4&quot;/&gt;
</code></pre>

<p>当前获得HTML5广泛支持的视频格式有三种：MP4、WebM和Ogg。给<code>&lt;video&gt;</code>元素指定高度和宽度是个很好的习惯，否则浏览器不知道应该保留多大面积的区域，会导致加载时改变页面布局。还建议在<code>&lt;video&gt;</code>和<code>&lt;/video&gt;</code>之间设置一些文本用于在不支持video标签的浏览器显示。</p>

<pre><code>&lt;video id=&quot;vid1&quot; width=&quot;400&quot; height=&quot;300&quot; controls=&quot;controls&quot; loop autoplay poster=&quot;Resources/bajian2.jpg&quot;&gt;
    &lt;source src=&quot;Resources/video.mp4&quot; type=&quot;video/mp4&quot; /&gt;
    &lt;source src=&quot;Resources/video.ogg&quot; type=&quot;video/ogg&quot; /&gt;
    &lt;source src=&quot;Resources/video.webm&quot; type=&quot;video/webm&quot; /&gt;
    &lt;p&gt;视频标签不被支持&lt;/p&gt;
&lt;/video&gt;
</code></pre>

<p>以下是<code>&lt;video&gt;</code>标签的一些重要属性：</p>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="left">描述</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">loop</td>
<td align="left">循环播放</td>
</tr>

<tr>
<td align="center">autoplay</td>
<td align="left">视频加载后自动播放</td>
</tr>

<tr>
<td align="center">controls</td>
<td align="left">显示回放控件(其外观取决于浏览器)</td>
</tr>

<tr>
<td align="center">ended</td>
<td align="left">回放结束时，值为true(只读)</td>
</tr>

<tr>
<td align="center">paused</td>
<td align="left">回放结束时，值为true(只读)</td>
</tr>

<tr>
<td align="center">poster</td>
<td align="left">设置影片加载时显示的图片</td>
</tr>

<tr>
<td align="center">volume</td>
<td align="left">音量，值是从0(静音)到1(最大)</td>
</tr>
</tbody>
</table>

<p>访问这些属性的方式与对待其他JavaScript或DOM对象是一样的：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        function btnClick() {
            var myVideo = document.getElementById(&quot;vid1&quot;).volume += -0.5;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;video id=&quot;vid1&quot; width=&quot;400&quot; height=&quot;300&quot; controls=&quot;controls&quot; loop autoplay poster=&quot;Resources/bajian2.jpg&quot;&gt;
        &lt;source src=&quot;Resources/video.mp4&quot; type=&quot;video/mp4&quot; /&gt;
        &lt;source src=&quot;Resources/video.ogg&quot; type=&quot;video/ogg&quot; /&gt;
        &lt;source src=&quot;Resources/video.webm&quot; type=&quot;video/webm&quot; /&gt;
        &lt;p&gt;视频标签不被支持&lt;/p&gt;
    &lt;/video&gt;&lt;br /&gt;
    &lt;input type=&quot;button&quot; value=&quot;减音量&quot; onclick=&quot;btnClick()&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>以及在视频暂停时向用户显示提示消息：</p>

<pre><code>if (document.getElementById(&quot;vid1&quot;).paused) {
            alert(&quot;累了就休息下吧.&quot;);
        }
</code></pre>

<p>利用JavaScript的canPlayType(type)方法可以检查对特定解码器的支持，其中type是表示媒体类型的字符串，比如&rdquo;video/mp4&rdquo;.如果浏览器确定支持指定的内容，这个方法会返回一个空字符串，如果浏览器认为它支持指定格式，方法会返回&rdquo;probably&rdquo;，其他情况就会返回&rdquo;maybe&rdquo;。</p>

<p>利用pause()和play()命令也可以控制视频回放：</p>

<pre><code>var myVideo = document.getElementById(&quot;vid1&quot;).pause();
var myVideo = document.getElementById(&quot;vid1&quot;).play();
</code></pre>

<h4 id="用-audio-标签播放声音">用<code>&lt;audio&gt;</code>标签播放声音</h4>

<p><code>&lt;audio&gt;</code>标签与<code>&lt;video&gt;</code>标签类似，使用<code>&lt;audio&gt;</code>元素最简单的方法是：</p>

<pre><code>&lt;audio src=&quot;Resources/一身诗意千寻瀑.mp3&quot;&gt;&lt;/audio&gt;
</code></pre>

<p>还可以对回放进行更多的控制：</p>

<pre><code>&lt;audio src=&quot;Resources/一身诗意千寻瀑.mp3&quot; autoplay loop&gt;&lt;/audio&gt;
</code></pre>

<p>像前面处理视频文件一样，我们可以包含多个不同的格式，以确保浏览器可以找到自己能播放的格式，<code>&lt;audio&gt;</code>元素支持的常见文件格式是MP3、WAV和Ogg：</p>

<pre><code>&lt;audio controls&gt;
    &lt;source src=&quot;Resources/一身诗意千寻瀑.mp3&quot;  type=&quot;audio/mp3&quot;/&gt;
    &lt;source src=&quot;Resources/一身诗意千寻瀑.ogg&quot; type=&quot;audio/ogg&quot; /&gt;
    &lt;p&gt;你的浏览器不支持音频播放&lt;/p&gt;
&lt;/audio&gt;
</code></pre>

<p>在JavaScript中控制音频的方式和针对<code>&lt;video&gt;</code>使用的方法差不多。利用JavaScript添加和播放音频文件时，只需要把它当作JavaScript或DOM对象即可：</p>

<pre><code>var soundElement = document.createElement('audio');
soundElement.setAttribute('src', 'Resources/一身诗意千寻瀑.mp3');
soundElement.play();
soundElement.pause();
</code></pre>

<p><code>&lt;audio&gt;</code>和<code>&lt;video&gt;</code>标签有很多可用的属性可以通过JavaScript进行控制，下面列出了一些，它们是立即发挥作用的：</p>

<pre><code>mediaElement.duration //持续时间
mediaElement.currentTime //跳转到播放内容的多少秒
mediaElement.playbackRate //播放速率
mediaElement.muted //静音
</code></pre>

<h4 id="利用-canvas-在页面上绘图">利用<code>&lt;canvas&gt;</code>在页面上绘图</h4>

<p><code>&lt;canvas&gt;</code>标签能够提供的时页面上的一个矩形区域，我们可以利用JavaScript在其中绘制图形和图像，也可以加载和展现图像文件并控制其显示方式。这个元素有很多实用领域，比如动态图标，JavaScript/HTML游戏和受控动画。<code>&lt;canvas&gt;</code>元素只是通过width和height参数定义一个矩形区域，其他与创建图形内容相关的内容都是通过JavaScript实现的。Canvas 2D API就是绘画方法的一个大集合。</p>

<p><code>&lt;canvas&gt;</code>唯一支持的形状就是简单的矩形：</p>

<pre><code>fillRect(x,y,width,height) //绘制一个填充的矩形
strokeRect(x,y,width,height) //绘制一个矩形框
clearRect(x,y,width,height) //绘制一个矩形框
</code></pre>

<p>其他形状的就需要使用一个或多个路径绘制函数才能实现。<code>&lt;canvas&gt;</code>提供了很多不同的路径绘制函数：</p>

<pre><code>moveTo(x,y) //会移动到指定位置，不绘制任何东西。
lineTo(x,y) //会从当前位置到指定位置绘制一条直线。
arc(x,y,r,startAngle,endAngle,anti) //绘制弧线，圆心位置是xy，半径是r，起始角度是startAngle，结束角度是endAngle，默认的绘制方向是顺时针。如果最后一个参数是true，就会以逆时针方向绘制。
</code></pre>

<p>为了使用这些基本命令来绘制形状，还需要其他方法：</p>

<pre><code>object.beginPath();
object.closePath(); //完成剩余部分形状
object.stroke(); //绘制轮廓形状
object.fill(); //绘制填充形状
</code></pre>

<p>利用<code>&lt;canvas&gt;</code>实现一个简单的动画，就是一个红色圆盘（表示一个球）在页面上以圆形轨迹运动。示例如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script&gt;
        var context;
        var x = 50;
        var y = 50;
        var counter = 0;
        function paint() {
            context.beginPath();
            context.fillStyle = &quot;#ff0000&quot;;
            context.arc(x, y, 15, 0, Math.PI * 2, false);
            context.closePath();
            context.fill();
        }

        function animate() {
            context.clearRect(0, 0, 400, 300);
            counter++;
            x += 20 * Math.sin(counter);
            y += 20 * Math.cos(counter);
            paint();
        }

        window.onload = function () {
            context = canvas1.getContext('2d');//首先需要指定渲染环境
            setInterval(animate, 100);
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id=&quot;canvas1&quot; width=&quot;400&quot; height=&quot;300&quot;&gt;
        &lt;P&gt;你的浏览器不支持画布元素&lt;/P&gt;
    &lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="html5拖放操作">HTML5拖放操作</h3>

<p>拖放操作是HTML5标准的组成部分，几乎页面上的所有东西都是可以拖放的，只需要设置他的draggable属性为true：</p>

<pre><code>&lt;img src=&quot;Resources/bajian2.jpg&quot; width=&quot;300&quot; height=&quot;500&quot; draggable=&quot;true&quot; /&gt;
</code></pre>

<p>拖动操作本身没什么意义，需要被拖动的元素可以放下才有意义。为了定义元素能够被放到什么位置，并且控制拖动和放下的过程，我们需要编写事件监听器来检测和控制拖放过程的各个部分。能够用于控制拖放操作的事件有：</p>

<ul>
<li>dragstart</li>
<li>drag</li>
<li>dragenter</li>
<li>dragleave</li>
<li>dragover</li>
<li>drop</li>
<li>dragend</li>
</ul>

<p>为了控制拖放操作，我们需要定义源元素（拖放开始的地方）、数据（拖动的对象）和放置目标（捕获拖动元素的区域）。<strong>不是任何元素都能够作为放置区域的，比如<code>&lt;img&gt;</code>就不能接受放置操作。</strong></p>

<p>dataTransfer属性包含的数据会在拖放操作中进行传递，它通常在dragstart事件处理器里进行设置，由drop事件处理器里进行读取和设置。setData(format.data)和getData(format.data)分别用于这个属性的设置和读取。示例如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        body { background-color:#ddd;font-family:Arial,Verdana,sans-serif; }
        #drop1 { width:200px;height:200px;border:1px solid black; background-color:white}
        #drag1 {width:80px;height:150px;}
    &lt;/style&gt;
    &lt;script&gt;
        //代码定义了三个重要的函数，他们都会接收到当前处理的事件

        //函数在拖动元素经过放置区域时执行，它的作用是阻止放置区域执行默认操作（因为默认的行为就是不允许拖动）
        function allowDrop(ev) {
            ev.preventDefault();
        }

        //函数在拖放开始时执行，它把dataTransfer属性设置为拖动元素的id
        function drag(ev) {
            ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);
        }

        //函数会在拖动元素被放下时执行，他会读取dataTransfer属性的值来获得拖动元素的id，把这个元素设置为放置区域的子元素。这时仍需要阻止放置区域执行默认操作。
        function drop(ev) {
            var data = ev.dataTransfer.getData(&quot;Text&quot;);
            ev.target.appendChild(document.getElementById(data));//ev.target在后台会基于拖放操作的状态而自动修改为相应的事件类型。
            ev.preventDefault();
        }

        window.onload = function () {
            var dragged = document.getElementById(&quot;drag1&quot;);
            var drophere = document.getElementById(&quot;drop1&quot;);
            dragged.ondragstart = drag;
            drophere.ondragover = allowDrop;
            drophere.ondrop = drop;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;drop1&quot;&gt;&lt;/div&gt;  &lt;!--捕获拖放操作的放置区域--&gt;
    &lt;p&gt;Drag the image below into the box above:&lt;/p&gt;
    &lt;img id=&quot;drag1&quot; src=&quot;Resources/bajian2.jpg&quot; draggable=&quot;true&quot;/&gt;&lt;!--要拖动的元素--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="本地存储">本地存储</h3>

<p>HTML5能够在用户的浏览器里保存大量的数据，同时对站点的性能不会造成任何影响。与使用cookies相比，web存储更加安全和快速。与cookies相同的是，数据也是以&rdquo;关键字/值&rdquo;对的方式存储的，而且web页面只能访问自己存储的数据。在浏览器里实现本地数据存储的两个新对象如下：</p>

<ul>
<li>localStorage：存储数据，没有过期时间。</li>
<li>SessionStorage：只在当前会话中存储数据。</li>
</ul>

<p>如果不能确定浏览器是否支持本地存储，解决的办法仍然是使用功能检测：</p>

<pre><code>if (typeof (Storage) != &quot;undefined&quot;) {
       //使用两个新对象进行操作
   }
</code></pre>

<p>保存数据有两种方式。一种是调用setItem方法，向他传递一个关键字和一个值，另一种是像操作关联数组一样使用localStorage对象：</p>

<pre><code>localStorage.setItem(&quot;key&quot;, &quot;value&quot;);
localStorage[&quot;key&quot;] = &quot;Value&quot;;
</code></pre>

<p>获取数据也可以用以下两种方式的一种：</p>

<pre><code>alert(localStorage.getItem(&quot;key&quot;));
alert(localStorage[&quot;key&quot;]);
</code></pre>

<h3 id="操作本地文件">操作本地文件</h3>

<p>HTML5的文件API规范让我们终于有一种标准方式来访问用户的本地文件了，具体途径有多种：</p>

<ul>
<li>File：提供的信息包括名称、大小和MIME类型，以及对文件句柄的引用。</li>
<li>FileList：类似数组的File对象列表。</li>
<li>FileReader：使用File和FileList异步读取文件的接口。我们可以查看读取进程、捕获错误、判断文件何时加载完成。</li>
</ul>

<p>利用功能检测功能可以查看浏览器是否支持文件API：</p>

<pre><code>if(window.File &amp;&amp; window.FileList &amp;&amp; window.FileReader){
    //进行操作
}
</code></pre>

<p>与本地文件交互：</p>

<p>我们将修改前一个拖放操作的范例，实现多个本地文件拖放到web页面的操作。要做到这点，方法是使用FileList数据结构。修改后的drop(ev)函数是这样的：</p>

<pre><code>function drop(ev) {
        var files = ev.dataTransfer.files;
        for (var i = 0; i &lt; files.length; i++) {
            var f = files[i];
            var pnode = document.createElement(&quot;P&quot;);
            var tnode = document.createTextNode(f.name + &quot;(&quot; + f.type + &quot;)&quot; + f.size + &quot;bytes&quot;);
            pnode.appendChild(tnode);
            ev.target.appendChild(pnode);//ev.target在后台会基于拖放操作的状态而自动修改为相应的事件类型。
        }
        ev.preventDefault();
    }
</code></pre>

<p>在这里程序从dataTransfer对象读取了FileList，它包含了拖放文件的信息：</p>

<pre><code>var files = ev.dataTransfer.files;
</code></pre>

<p>完整代码如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        body {
            background-color: #ddd;
            font-family: Arial,Verdana,sans-serif;
        }

        #drop1 {
            width: 1000px;
            height: 200px;
            border: 1px solid black;
            background-color: white;
        }

        #drag1 {
            width: 80px;
            height: 150px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        //代码定义了三个重要的函数，他们都会接收到当前处理的事件

        //函数在拖动元素经过放置区域时执行，它的作用是阻止放置区域执行默认操作（因为默认的行为就是不允许拖动）
        function allowDrop(ev) {
            ev.preventDefault();
        }

        //函数会在拖动元素被放下时执行，他会读取dataTransfer属性的值来获得拖动文件的信息
        function drop(ev) {
            var files = ev.dataTransfer.files;
            for (var i = 0; i &lt; files.length; i++) {
                var f = files[i];
                var pnode = document.createElement(&quot;P&quot;);
                var tnode = document.createTextNode(f.name + &quot;(&quot; + f.type + &quot;)&quot; + f.size + &quot;bytes&quot;);
                pnode.appendChild(tnode);
                ev.target.appendChild(pnode);//ev.target在后台会基于拖放操作的状态而自动修改为相应的事件类型。
            }
            ev.preventDefault();
        }

        window.onload = function () {
            var drophere = document.getElementById(&quot;drop1&quot;);
            drophere.ondragover = allowDrop;
            drophere.ondrop = drop;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;drop1&quot;&gt;&lt;/div&gt;  &lt;!--捕获拖放操作的放置区域--&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="html5小结">HTML5小结</h3>

<p>HTML5为HTML提供了一系列新功能，让这种标签语言更好的完成web应用的基础工作，也让JavaScript能够使用使用一些崭新的API。学习HTML5最佳的途径是使用它，利用HTML5的特性建立页面，比如使用语义明确的标签，尝试音频和视频回放，尝试拖放操作，使用本地存储，使用文件API，使用<code>&lt;canvas&gt;</code>建立动画。遇到问题，互联网上有很多教程、博客和范例代码都可以提供帮助。</p>

<h2 id="javascript和css">Javascript和CSS</h2>

<h3 id="css简介">CSS简介</h3>

<h4 id="从内容分离样式">从内容分离样式</h4>

<p>CSS致力于把HTML的样式与其标签功能分离，方法是定义单独的样式声明，然后把它们应用于HTML元素或者元素的集合。可以使用CSS设置页面元素可视属性的样式（比如颜色、字体和大小）以及与格式有关的属性（比如位置、页边距、填充和对齐）。样式和内容的分离会有这样的好处：</p>

<ul>
<li>样式的声明可以应用于多个元素甚至是多个页面（使用外部样式表）。</li>
<li>修改样式声明就可以影响全部相关的HTML元素，使更新站点样式更加准确、迅速和高效。</li>
<li>共用样式可能够提高站点的样式一致性。</li>
<li>HTML标签更加清晰、易读和可维护。</li>
</ul>

<h4 id="css样式声明">CSS样式声明</h4>

<p>假设我们要给页面全部段落元素声明一个样式，设置段落的字体颜色是红色，如果有多个样式规则，这些规则要以分号分隔：</p>

<pre><code>&lt;style&gt;
    p{
        color:red;
        text-decoration:line-through
    }
&lt;/style&gt;
</code></pre>

<p>如果只想给某个特定的页面元素设置，可以利用它的ID，CSS样式声明的选择符就不是HTML元素的名称了，而是元素的id前面添加一个&rdquo;#&ldquo;，举例来说：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
    #para1{
        font-weight:bold;
        font-size:12px;
        color:black;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p id=&quot;para1&quot;&gt;这里是一些文字。&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>如果想让多种页面元素共享一个样式声明，只需要用逗号分隔多个选择符。如下则会影响到所有div元素和id为para1的元素：</p>

<pre><code>div,#para1{
       color:yellow;
       background-color:black;
   }
</code></pre>

<p>另外我们还可以用class属性对元素归类，在类前面添加一个句点作为选择符：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .info {
            font-family:Arial,Verdana,sans-serif;
            color:green;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p class=&quot;info&quot;&gt;这里是一些文字。&lt;/p&gt;
    &lt;span class=&quot;info&quot;&gt;这里是一些span元素。&lt;/span&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="在哪里保存样式声明">在哪里保存样式声明</h4>

<p>与JavaScript相似，CSS样式声明可以出现在页面里，也可以保存到外部文件中并从HTML页面里引用。为了引用外部的样式表，通常做法是在页面<code>&lt;head&gt;</code>部分添加这一行：</p>

<pre><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt;
</code></pre>

<p>另外可以把样式直接放到页面的<code>&lt;head&gt;</code>部分，用一对<code>&lt;style&gt;</code>和<code>&lt;/style&gt;</code>标签包围：</p>

<pre><code>&lt;style&gt;
    .info {
        font-family:Arial,Verdana,sans-serif;
        color:green;
    }
    div,#para1{
       color:yellow;
       background-color:black;
   }
&lt;/style&gt;
</code></pre>

<p>最后要说明的是，利用style属性可以把样式声明直接添加到HTML元素：</p>

<pre><code>&lt;p style=&quot;color:yellow;font-size:12px&quot;&gt;这里是一些文字。&lt;/p&gt;
</code></pre>

<h3 id="dom的style属性">DOM的style属性</h3>

<p>HTML页面在浏览器里面以DOM树的形式表现，组成DOM树的分支和末端称为节点。它们都是一个个的对象，都具有自己的属性和方法。</p>

<p>每个DOM节点都有一个Style属性，这个属性本身也是一个对象，包含了应用于节点的CSS样式信息。</p>

<pre><code>&lt;div id=&quot;id1&quot; style=&quot;width:200px&quot;&gt;欢迎来到我的网站。&lt;/div&gt;
&lt;script&gt;
    var mynode = document.getElementById(&quot;id1&quot;);
    alert(mynode.style.width);
&lt;/script&gt;
</code></pre>

<p>除了使用mynode.style.width这一语法，也可以使用其对等的形式mynode.style[&ldquo;width&rdquo;]。有时候这样做是必要的，比如把属性的名称作为变量传递的时候：</p>

<pre><code>var myProperty = &quot;width&quot;;
mynode.style[myProperty] = 200px;
</code></pre>

<p>遗憾的是虽然这种方式在用于内联样式的时候很正常，但如果在页面<code>&lt;head&gt;</code>部分使用<code>&lt;style&gt;</code>元素，或是使用外部样式表来设置页面元素的样式，DOM的style对象就不能访问它们了。</p>

<p>CSS的很多属性名称包含连字符，比如background-color,font-size等，但是JavaScript不允许在属性或者方法中使用连字符，因此需要调整这些名称的书写方式，方法是删除其中的连字符，并且把连字符后面的字母大写，就像是backgroundColor，fontSize。</p>

<p>编写一个函数，使用DOM的style对象让页面的背景颜色和字体在两个值之间切换。程序清单如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        span{
            font-size:16pt;
            font-family:Arial, Helvetica, sans-serif;
            padding:20px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        function toggle() {
            var myElement = document.getElementById(&quot;id1&quot;);
            if(myElement.style.backgroundColor == &quot;red&quot;)
            {
                myElement.style.backgroundColor = &quot;yellow&quot;;
                myElement.style.color = &quot;black&quot;;
            }
            else
            {
                myElement.style.backgroundColor = &quot;red&quot;;
                myElement.style.color = &quot;white&quot;;
            }
        }

        window.onload = function () {
            document.getElementById(&quot;btn1&quot;).onclick = toggle;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;span id=&quot;id1&quot;&gt;欢迎来到我的网站。&lt;/span&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;切换&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="classname访问类">className访问类</h3>

<p>一般情况下，为了调整页面样式而不覆盖相应的样式声明，利用元素的className属性，我们就可以通过修改class属性的值来调整应用于元素的样式。程序清单如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        .classA {
        width:180px;
        border:3px solid black;
        background-color:white;
        color:red;
        font: normal 24px arial,helvetica,sans-serif;
        padding:20px;
        }

        .classB {
        width:180px;
        border:3px dotted white;
        background-color:black;
        color:yellow;
        font: italic bold 24px &quot;Times New Roman&quot;,serif;
        padding:20px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        function toggleClass() {
            var myElement = document.getElementById(&quot;id1&quot;);
            if (myElement.className == &quot;classA&quot;)
            {
                myElement.className = &quot;classB&quot;;
            }
            else
            {
                myElement.className = &quot;classA&quot;;
            }
        }

        window.onload = function () {
            document.getElementById(&quot;btn1&quot;).onclick = toggleClass;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;id1&quot; class=&quot;classA&quot;&gt;欢迎来到我的网站。&lt;/div&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;切换&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="dom的stylesheet对象">DOM的styleSheet对象</h3>

<p>document对象的styleSheet属性是一个数组，包含了页面上全部样式表，无论样式表是在外部文件中还是在页面内的。styleSheet数组里的项目以数值索引，第一个出现的样式索引为0。数组里的每个样式表都有一个属性disable，其值为true或者false。它是可读写的，可以方便地启用或者禁用某个样式表。</p>

<pre><code>document.stylesheet[0].disabled = true; //禁用第一个样式表
</code></pre>

<p>切换样式表示例：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        body {
            background-color:white;
            color:red;
        padding:20px;
        }
        &lt;/style&gt;
    &lt;style&gt;
        body {
            background-color:black;
            color:yellow;
            padding:20px;
        }
    &lt;/style&gt;
    &lt;script&gt;
        var whichSheet = 0;
        document.styleSheets[1].disabled = true;

        function sheet() {
            document.styleSheets[whichSheet].disabled = true;
            whichSheet = (whichSheet == 1) ? 0 : 1;
            document.styleSheets[whichSheet].disabled = false;
        }

        window.onload = function () {
            document.getElementById(&quot;btn1&quot;).onclick = sheet;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    用按钮切换样式表！&lt;br /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;切换&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="选择特定样式表">选择特定样式表</h4>

<p>虽然样式表具有数值索引，但是并不便于选择，如果给样式表设置标题，并编写一个函数，根据title选择就会很容易。程序清单如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style title=&quot;sheet1&quot;&gt;
        body {
            background-color: white;
            color: red;
        }
    &lt;/style&gt;

    &lt;style title=&quot;sheet2&quot;&gt;
        body {
            background-color:black;
            color:yellow;
        }
    &lt;/style&gt;

    &lt;style title=&quot;sheet3&quot;&gt;
        body {
            background-color: pink;
            color: green;
        }
    &lt;/style&gt;

    &lt;script&gt;       
        function ssEnable(mysheet) {
            var change = false;
            var oldsheet = 0;
            for (var i = 0; i &lt; document.styleSheets.length; i++)
            {
                //一般情况下，如果有多个可以应用的样式表，只有第一个是启用的
                if (document.styleSheets[i].disabled == false)
                {
                    oldsheet = i;
                }

                document.styleSheets[i].disabled = true;
                if(document.styleSheets[i].title == mysheet)
                {
                    document.styleSheets[i].disabled = false;
                    change = true;
                }
            }

            if (!change)
                document.styleSheets[oldsheet].disabled = false;

            return change;
        }

        function sheet()
        {
            var sheetName = prompt(&quot;Stylesheet Name?&quot;);
            if(!ssEnable(sheetName))
            {
                alert(&quot;没找到这个样式表，原来的样式表保持&quot;);
            }
        }

        window.onload = function () {
            document.getElementById(&quot;btn1&quot;).onclick = sheet;
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    用按钮切换样式表！&lt;br /&gt;
    &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;切换&quot; /&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="javascript样式表小功能">JavaScript样式表小功能</h3>

<p>JavaScript可以变换鼠标指示，在style对象有一个cursor属性，可以设置一些不同的值来表示鼠标的形状，常见的包括：</p>

<ul>
<li>十字：像瞄准器一样的十字。</li>
<li>指针：通常的指针形状。</li>
<li>文本：插入文本的提示符。</li>

<li><p>等待：表示程序忙。</p>

<h2 id="css3简介">CSS3简介</h2>

<p>使用CSS3可以很容易的实现很多酷炫的新效果，而不需要很多的JavaScript代码或者像PS这样单独的图形应用程序。你可以创建圆角的边框，给方框添加阴影，使用图像作为边框等等。CSS3包含了几个新的背景属性，使得你更好的控制背景元素，包含多个背景图像，而CSS3渐变允许你显示两种或者多种特定颜色之间的平滑过渡。新的文本功能包括文本阴影和单词换行，以及易于使用的web字体。CSS3使你可以很容易的构建真正酷炫的过度、变换和动画。</p></li>
</ul>

<h3 id="特定厂商属性和前缀">特定厂商属性和前缀</h3>

<p>CSS3浏览器前缀如下：
<img src="https://sltaurusblog.gitee.io/images/JavaScript/JavaScript24.jpg" alt="JavaScript24" /></p>

<p>当需要使用CSS3规范中的属性且需要使用一个前缀的时候，针对所使用的浏览器，添加上表的前缀就可以了。示例：</p>

<pre><code>-webkit-transition：backgroud 0.5s ease；
-moz-transition：backgroud 0.5s ease；
-o-transition：backgroud 0.5s ease；
transition：backgroud 0.5s ease；
</code></pre>

<p>用户的浏览器将会对它所理解的过渡功能版本做出响应而忽略其他版本。现在需要添加前缀的属性正在飞速减少，哪些功能/浏览器组合需要一个前缀可以在<a href="http://shouldiprefix.com">http://shouldiprefix.com</a>查询。一个属性的前缀的版本可能并不总是与CSS3规范所描述的相同，特定厂商扩展几乎肯定会在CSS验证中失败。</p>

<h3 id="css3边框">CSS3边框</h3>

<p>CSS3允许我们对边框做一些很酷的东西，这些在以前只能使用大量复杂的且难以维护的代码去实现。</p>

<h4 id="创建边框阴影">创建边框阴影</h4>

<p>box-shadow属性允许你为页面的box元素添加阴影，可以分别为颜色、大小、模糊和偏移量指定值。box-shadow属性的参数如下：</p>

<table>
<thead>
<tr>
<th align="center">阴影参数</th>
<th align="center">动作</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">h-shadow(必须的)</td>
<td align="center">水平阴影的位置，复制是不允许的</td>
</tr>

<tr>
<td align="center">v-shadow(必须的)</td>
<td align="center">垂直阴影的位置，复制是不允许的</td>
</tr>

<tr>
<td align="center">blur(可选的)</td>
<td align="center">模糊距离</td>
</tr>

<tr>
<td align="center">spread(可选的)</td>
<td align="center">阴影的大小</td>
</tr>

<tr>
<td align="center">color(可选的)</td>
<td align="center">阴影的颜色，默认为黑色</td>
</tr>
</tbody>
</table>

<p>以下是一个10像素宽的向下和向右伸展的阴影，在其整个宽度中模糊，并且颜色为中度灰的示例：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color: #00ff21;
            width:400px;
            height:250px;
            box-shadow:10px 10px 10px #808080;
        }        
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="用border-radius属性实现圆角">用border-radius属性实现圆角</h4>

<p>border-radius属性允许我们给页面元素添加圆角，而不需要专门创建圆角图像。示例如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-color:#ffd800;
            width:200px;
            height:200px;
            border-radius:25px;
        }        
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>可以使用单独的border-bottom-left-radius、border-top-left-radius、border-top-right-radius和border-bottom-right-radius属性来分别指定圆角，或者像我们所做的那样在一条语句中使用border-radius属性指定所有的4个圆角。</p>

<h3 id="css3背景">CSS3背景</h3>

<p>CSS3包含了几个新的背景属性，它们使得你更好的控制背景元素。</p>

<h4 id="backgroud-size属性">backgroud-size属性</h4>

<p>backgroud-size属性允许使用长度、百分比，或者另外的两个关键字contain或cover来设置图像的大小。当使用百分比的时候他们是相对于背景的可用空间，而不是相对于背景图像的宽度和高度。auto关键字用于替代width或height的值，如果只为backgroud-size属性指定了一个值，会认为是其宽度，然后高度默认为是auto。示例：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-size:400px;
            background-image:url(/Resources/bajian.jpg);
            width: 400px;
            height: 250px;
            border-radius:25px;
        }        
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="backgroud-origin属性">backgroud-origin属性</h4>

<p>backgroud-origin属性用于设置一个背景在框中的位置如何计算。backgroud-origin属性接受如下三个值：padding-box（默认值）、border-box和content-box。当你提供了padding-box值，其位置相对于边距边缘的左上角。使用border-box，其位置相对于边框的左上角，而content-box表示背景相对于内容的左上角来定位。</p>

<blockquote>
<p>Origin有“起源”的意思，而background-origin就有“背景图片起点”的意思。它是告诉浏览器background-position是相对于哪里定位的。在这里要用盒模型这个概念来解释，在CSS中元素被看成一个盒子，这个盒子被拆解为上面三个部分。</p>

<p>在CSS中，border-box区域的大小是由border属性控制的，padding-box区域的大小是由padding属性控制的，content-box区域的大小是由实际内容区域大小控制的。回到background-origin这个属性上来，它的三个值就好理解了。在CSS中页面的渲染性格是由页面左上角开始的，那么</p>

<ul>
<li>border-box就是把背景图片的坐标原点设置在盒模型border-box区域的左上角</li>
<li>padding-box就是把背景图片的坐标原点设置在盒模型padding-box区域的左上角</li>
<li>content-box就是把背景图片的坐标原点设置在盒模型content-box区域的左上角</li>
</ul>

<p><img src="https://sltaurusblog.gitee.io/images/JavaScript/backgroundOrigin.png" alt="backgroundOrigin" />
这里要注意一下，当background-attachment属性设置为fixed时，background-origin属性会失效。参考教程: <a href="https://blog.csdn.net/weixin_39256994/article/details/78698145">CSS background-origin属性</a></p>
</blockquote>

<h4 id="多背景图像">多背景图像</h4>

<p>CSS3允许我们对框元素使用多个背景图像，直接使用逗号隔开的一个列表就可以了。列表的顺序很重要，所提供的第一个值表示距离用户最近的层，列表中的后续条目会作为该层之后的后续层实现，示例如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            background-size:400px;
            background-image:url(/Resources/bajian.jpg),url(/Resources/bajian2.jpg);
            width: 600px;
            height: 350px;
            background-position:center bottom,left top;
            background-repeat:no-repeat;
        }        
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="css3渐变">CSS3渐变</h3>

<p>CSS3渐变允许你在两种或者多种指定的颜色之间生成平滑的过渡，而在此之前必须使用图像来实现这种效果。和使用图像相比，使用CSS3渐变可以减少下载的时间，节省缓存空间，减少宽带的使用。当使用缩放的时候，CSS3渐变也执行的很好。</p>

<p>CSS3提供了两种类型的渐变：线性渐变（分别沿着上/下/左/右/对角线的方向进行）；还有放射性渐变，从一个确定的中心点向外围放射。</p>

<h4 id="线性渐变">线性渐变</h4>

<p>要使用CSS3创建线性渐变，必须定义两种颜色作为渐变的端点。也可以为渐变定义一个起点和一个方向（上/下/左/右/对角线），如果没有为渐变定义一个方向，浏览器会默认使用从上到下的方向。示例如下：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            width: 600px;
            height: 350px;
            background: linear-gradient(red,#00ff21)
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>也可以为渐变输入一个方向，从左到右的示例：
    background: linear-gradient(to right, red,#00ff21);
沿对角线方向的渐变示例：</p>

<pre><code>background: linear-gradient(to bottom right, red,#00ff21);
</code></pre>

<p>还可以定义一个角度来完全控制渐变的方向：</p>

<pre><code>background: linear-gradient(135deg, red,#00ff21);
</code></pre>

<h4 id="放射渐变">放射渐变</h4>

<p>放射渐变由其中心确定，并且也必须至少定义两种颜色，作为渐变的端点：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        #div1 {
            width: 600px;
            height: 350px;
            background: radial-gradient(red,#21bd54);
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>也可以用关键字at，为放射渐变设置一个位置参数：</p>

<pre><code>background: radial-gradient(at top left ,red,#21bd54);
</code></pre>

<h4 id="其他渐变">其他渐变</h4>

<p>CSS3渐变能做的还很多，还包括使用两种以上的颜色、透明度，以及修改渐变的形状，大小等，甚至可以为相同的元素添加多做渐变，完整的介绍详见W3C的文档，位于<a href="https://www.w3.org/TR/css3-images/">https://www.w3.org/TR/css3-images/</a></p>

<h3 id="css3文本效果">CSS3文本效果</h3>

<h4 id="文本阴影">文本阴影</h4>

<p>box-shadow属性可以对块元素添加阴影，在CSS3中，text-shadow属性为文本添加阴影的方式与其如出一辙，可以为阴影指定水平的和垂直的阴影距离以及可选的模糊距离，并且指定阴影的颜色：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        h1 {
            text-shadow:10px 10px 3px #808080;
            font-size:26px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;测试阴影&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="单词换行">单词换行</h4>

<p>如果一句话太长了，块元素无法包含它，它会超出其容器的范围。在CSS3中可以使用word-wrap属性强制让单词换行，即使是从一个单词的中间换行也可以：</p>

<pre><code>p{
        word-wrap:break-word;
    }
</code></pre>

<h3 id="css3过渡-变换和动画">CSS3过渡、变换和动画</h3>

<p>CSS3可以用一种容易的方式为页面上的元素添加简单的效果，以过渡、变换和动画的形式呈现。在下面的示例中我们添加了一个过渡的效果，以便在链接上悬停的时候变换背景颜色。随着背景颜色的变化，过渡效果将平滑的进行。</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
        a.trans {
            background:#00ffff;
            transition:background 0.5s ease;
        }
        a.trans:hover{
            background:red;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;https://www.baidu.com/&quot; class=&quot;trans&quot; id=&quot;link1&quot;&gt;测试用例&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="在javascript中引用css3属性">在JavaScript中引用CSS3属性</h3>

<p>CSS3和JavaScript组合起来，提供了一些很好的效果，而且性能不错、可靠性高，并且将代码的复杂度最小化。在本节，将介绍在JavaScript代码中成功获取和设置CSS3属性的一些方法。</p>

<h4 id="将css3属性名转换到javascript中">将CSS3属性名转换到JavaScript中</h4>

<p>要让CSS的属性的名称和JavaScript的命名系统兼容，CSS属性名需要从它们在样式表中的格式来进行一些转换，不在像是在CSS中使用小写名称和连字符，JavaScript去掉了连字符，并且将连字符后面的字母大写，本身没有连字符的不需要改变，例如width还是width。</p>

<h4 id="dom的getcomputedstyle-方法">DOM的getComputedStyle()方法</h4>

<p>在前面的章节中访问元素的样式属性用 <code>document.getElementById(&quot;div1&quot;).style.background</code> 类似的写法，但是它只作用于内联样式的元素，对于那些将CSS声明组织到页面头部的<code>&lt;style&gt;</code>元素中的元素，或者将CSS声明在外部文件中的情况是无效的。</p>

<p>现在几乎所有浏览器都支持DOM的getComputedStyle()方法，它可以访问一个元素最终的(也就是计算后的)样式。最终样式就是浏览器以适应顺序应用了与该元素相关的所有样式规则之后，最终显示该元素的样式。getComputedStyle()方法返回一个对象，这个对象包含各种方法，包括getPropertyValue(property)方法，这个方法返回了给定的CSS属性名的当前值。</p>

<p>下面是一个使用box-shadow和radial-gradient来实现的控制光照的HTML小示例：</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style&gt;
    #div1{
        width:600px;
        height:350px;
        background-color:#6699cc;
        border-radius:25px;
        box-shadow:10px 10px 10px #808080;
    }
    #div2{
        background-color:#f8f405;
        width:80px;
        height:80px;
        padding:20px;
        position:relative;
        left:240px;
        top105px;
        border-radius:25px;
        box-shadow:10px 10px 10px #808080;
    }
    #div3{
        text-align:center;
        align-content:center;
    }
    &lt;/style&gt;
    &lt;script&gt;
        window.onload = function () {
            document.getElementById(&quot;btn1&quot;).onclick = function () {
                document.getElementById(&quot;div1&quot;).style.background = &quot;radial-gradient(at top left,white,#6699cc)&quot;;
                document.getElementById(&quot;div2&quot;).style.boxShadow = &quot;10px 10px 10px #808080&quot;;
            }

            document.getElementById(&quot;btn2&quot;).onclick = function () {
                document.getElementById(&quot;div1&quot;).style.background = &quot;radial-gradient(at top right,white,#6699cc)&quot;;
                document.getElementById(&quot;div2&quot;).style.boxShadow = &quot;-10px 10px 10px #808080&quot;;
            }

            document.getElementById(&quot;btn3&quot;).onclick = function () {
                document.getElementById(&quot;div1&quot;).style.background = &quot;radial-gradient(at bottom,white,#6699cc)&quot;;
                document.getElementById(&quot;div2&quot;).style.boxShadow = &quot;0px -10px 10px #808080&quot;;
            }
        }
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;div1&quot;&gt;
        &lt;div id=&quot;div2&quot;&gt;
            &lt;div id=&quot;div3&quot;&gt;
                灯光:&lt;br /&gt;
                &lt;input type=&quot;button&quot; id=&quot;btn1&quot; value=&quot;左上&quot; /&gt;&lt;br /&gt;
                &lt;input type=&quot;button&quot; id=&quot;btn2&quot; value=&quot;右上&quot; /&gt;&lt;br /&gt;
                &lt;input type=&quot;button&quot; id=&quot;btn3&quot; value=&quot;底部&quot; /&gt;&lt;br /&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="设置带有厂商前缀的css3属性">设置带有厂商前缀的CSS3属性</h3>

<p>当一个浏览器支持一个特定的CSS属性，当从一个页面元素请求该属性的时候他会返回一个字符串值，如果还没有设置这个值就会返回一个空的字符串，如果浏览器不支持这个属性，返回的值将会是undefined。下面是显示接受潜在CSS3属性的一个数组并且返回浏览器支持的一种形式的代码：</p>

<pre><code>&lt;script&gt;
    function getCss3Property(properties) {
        //遍历所有可能的属性名
        for (var i = 0; i &lt; property.length; i++) {
            //如果该元素的这个属性存在
            if (properties[i] in document.documentElement.style) {
                //返回相关的字符串
                return properties[i];
            }
        }
    }
    //获取正确的CSS3过渡属性
    var myTrans = getCss3Property(['transition', 'MozTransition', 'WebkitTransition', 'msTransition', 'OTransition']);
    //为link1设置CSS3过渡
    document.getElementById(&quot;link1&quot;).style[myTrans] = &quot;background 0.5s ease&quot;;
&lt;/script&gt;
</code></pre>

<p>当调用的时候，getCss3Property()函数将开始遍历各种厂商类型对应的过渡属性的列表，对于过渡属性返回一个undefined值，最终返回一个字符串值MozTransition，现在知道后面是用这个属性该使用这个属性的哪一个版本了。</p>

<p>有几个浏览器厂商都使用-Webkit-前缀，-Webkit-是一个布局引擎用于在Web浏览器呈现Web页面，Webkit引擎是多个流行浏览器的基础，这些浏览器包括Safari、Chrome/Chromium，以及用于桌面和移动的平台的多种浏览器。</p>
	  </article>
    </section>

    <footer class="ui attached segment dream-tags">
      
        
          <a class="ui label" href="https://sltaurusblog.gitee.io/tags/javascript" title="JavaScript">JavaScript</a>
        
      
      <div
        class="ui label"
        style="float: right; background: #1b1c1d !important; cursor: pointer;"
        onclick="savePostAsImg()">
        <i class="save icon"></i> Save as image
      </div>
    </footer>

    

    
      <footer class="ui bottom attached stacked segment post-disqus-area" data-html2canvas-ignore="true">
        <div id="disqus_thread"></div>
        <script>
          


          var disqus_config = function () {
            this.page.url = 'https:\/\/sltaurusblog.gitee.io\/2019\/08\/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A\/';  
            this.page.identifier = '\/2019\/08\/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A\/'; 
          };

          (function() { 
            var d = document, s = d.createElement('script');
            s.src = 'https://' + '...' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </footer>
    

  </div>
  <div class="sixteen wide mobile sixteen wide tablet four wide computer column">
    <article class="dream-header">
  <section class="ui top attached center aligned segment">
    <div class="ui small circular image">
      
        <img src="https://sltaurusblog.gitee.io/images/head.jpg">
      
    </div>

    <h1 class="ui medium header">SLTaurus的博客<div class="sub header" style="margin-top: 0.5rem;">合抱之木，生于毫末；九层之台，起于累土；千里之行，始于足下。</div>
    </h1>

    <div class="ui horizontal list">
      
      <a class="item" href="https://sltaurusblog.gitee.io/tags">
        <i class="tags icon" title="所有标签"></i>
      </a>
      <a class="item" href="https://sltaurusblog.gitee.io/categories">
        <i class="th list icon" title="所有分类"></i>
      </a>
    </div>
  </section>

  
  <section class="ui attached center aligned segment dream-tags">
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ado.net" title="ado.net">ado.net</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ef" title="ef">ef</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/hugo" title="hugo">hugo</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/javascript" title="javascript">javascript</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8" title="markdown快速入门">markdown快速入门</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/markdown%E8%AF%AD%E6%B3%95%E5%AE%8C%E6%95%B4%E7%89%88" title="markdown语法完整版">markdown语法完整版</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/mvc" title="mvc">mvc</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/mysql" title="mysql">mysql</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/orm%E5%AF%B9%E6%AF%94" title="orm对比">orm对比</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/orm%E6%95%B4%E7%90%86" title="orm整理">orm整理</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/powershell" title="powershell">powershell</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/redis" title="redis">redis</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/ref%E5%92%8Cout" title="ref和out">ref和out</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/sqlservice" title="sqlservice">sqlservice</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98" title="内置泛型委托">内置泛型委托</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E5%8F%8D%E5%B0%84" title="反射">反射</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E7%B2%BE%E9%80%9Ac" title="精通c#">精通c#</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B" title="设计模式-创建型">设计模式-创建型</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99" title="设计模式-原则">设计模式-原则</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B" title="设计模式-结构型">设计模式-结构型</a>
    
      <a class="ui label" href="https://sltaurusblog.gitee.io/tags/%E9%A1%B9%E7%9B%AE" title="项目">项目</a>
    
  </section>
  

  
  <section class="ui attached segment dream-categories">
    <div class="ui accordion">
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/c" class="item">c#</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/11/%E5%86%85%E7%BD%AE%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98actionfunc%E5%92%8Cpredicate/" class="item">内置泛型委托：Action、Func和Predicate</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/%E5%8F%8D%E5%B0%84%E6%95%B4%E7%90%86%E4%B9%8B%E6%97%A5%E5%B8%B8%E7%94%A8%E9%80%94/" class="item">反射整理之日常用途</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/ado.net/" class="item">ADO.NET</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/mvc%E6%95%B4%E7%90%86/" class="item">MVC整理</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/%E7%B2%BE%E9%80%9Acsharp%E7%AC%AC%E5%85%AD%E7%89%88/" class="item">精通CSharp(第六版)</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/ref%E5%92%8Cout%E4%BD%BF%E7%94%A8%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB/" class="item">ref和out使用时的区别</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/javascript" class="item">javascript</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/09/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8B/" class="item">JavaScript入门经典第6版笔记(下)</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A/" class="item">JavaScript入门经典第6版笔记(上)</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/markdown" class="item">markdown</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/markdown%E8%AF%AD%E6%B3%95%E5%AE%8C%E6%95%B4%E7%89%88/" class="item">Markdown语法完整版</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/markdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" class="item">Markdown快速入门</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/orm" class="item">orm</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/efchloesqlsugardos.orm%E5%9B%9B%E7%A7%8Dorm%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AF%B9%E6%AF%94/" class="item">EF、Chloe、SqlSugar、DOS.ORM四种ORM框架的对比 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/entityframework/" class="item">EntityFramework</a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/orm%E6%95%B4%E7%90%86/" class="item">ORM整理</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/redis" class="item">redis</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/06/redis%E5%9F%BA%E7%A1%80/" class="item">Redis基础</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E5%8D%9A%E5%AE%A2" class="item">博客</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/08/windows10%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhugo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-git%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-valine%E8%AF%84%E8%AE%BA/" class="item">windows10环境下搭建Hugo个人博客&#43;git分布式版本控制&#43;valine评论</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93" class="item">数据库</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/mysql%E6%8B%BE%E9%81%97/" class="item">MySql拾遗 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2019/10/sqlservice%E7%AC%94%E8%AE%B0/" class="item">SqlService笔记</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E8%87%AA%E5%8A%A8%E5%8C%96" class="item">自动化</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/windows-powershell%E6%8C%87%E5%8D%97/" class="item">Windows PowerShell指南</a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" class="item">设计模式</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/" class="item">24种设计模式之设计模式原则 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A1%8C%E4%B8%BA%E5%9E%8B/" class="item">24种设计模式之行为型 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%93%E6%9E%84%E5%9E%8B/" class="item">24种设计模式之结构型 </a>
              </div>
            </div>
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/04/24%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%9E%8B/" class="item">24种设计模式之创建型 </a>
              </div>
            </div>
          
          </div>
        </div>
      
        <div class="title">
          <i class="dropdown icon"></i>
          <a href="https://sltaurusblog.gitee.io/categories/%E9%A1%B9%E7%9B%AE" class="item">项目</a>
        </div>
        <div class="content">
          <div class="ui list">
          
            <div class="item">
              <div class="content">
                <a href="https://sltaurusblog.gitee.io/2020/05/%E8%AE%A1%E4%BB%B6%E5%B7%A5%E8%B5%84%E9%A1%B9%E7%9B%AE/" class="item">计件工资项目</a>
              </div>
            </div>
          
          </div>
        </div>
      
    </div>
  </section>
  

  <section class="ui attached segment header-socials">
    <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <a href="mailto:1641061313@qq.com">
        <i class=" mail icon" title="email"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://twitter.com/SLTaurus" target="_blank">
        <i class=" twitter icon" title="twitter"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://facebook.com/SLTaurus" target="_blank">
        <i class=" facebook icon" title="facebook"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://instagram.com/SLTaurus" target="_blank">
        <i class=" instagram icon" title="instagram"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.linkedin.com/in/SLTaurus" target="_blank">
        <i class=" linkedin icon" title="linkedin"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://github.com/SLTaurus" target="_blank">
        <i class=" github icon" title="github"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.stackoverflow.com/users/SLTaurus" target="_blank">
        <i class=" stack overflow icon" title="stackoverflow"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://codepen.io/SLTaurus" target="_blank">
        <i class=" codepen icon" title="codepen"></i>
      </a>
    </div>
  
</nav>

  </section>

  <section class="ui bottom attached center aligned segment">
    
      <p>© 2019 - 2020 SLTaurus的博客</p>
    

    <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/g1eny0ung/hugo-theme-dream" target="_blank">Dream</a>.</p>
  </section>
</article>

  </div>
</div>

        </section>
        <section class="back">
          
<nav class="ui secondary inverted menu dream-menu">

  <div class="item">
    <i class="large link bullseye icon dream-flip-toggle" title="翻转！"></i>
  </div>
  <div class="item">
    <i class="large link home icon" title="首页" onclick="window.location.href = 'https:\/\/sltaurusblog.gitee.io'"></i>
  </div>
  <div class="item">
    <i class="large link icon theme-switch" onclick="themeSwitch()"></i>
  </div>
</nav>

          <div class="ui centered relaxed grid dream-grid dream-back">
  

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    <article>
      <div class="ui top attached segment">
        <h3 class="ui header">社交链接</h3>
      </div>
      <div class="ui attached segment">
        <nav class="ui secondary menu dream-menu dream-socials">
  
    <div class="item">
      <a href="mailto:1641061313@qq.com">
        <i class="large mail icon" title="email"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://twitter.com/SLTaurus" target="_blank">
        <i class="large twitter icon" title="twitter"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://facebook.com/SLTaurus" target="_blank">
        <i class="large facebook icon" title="facebook"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://instagram.com/SLTaurus" target="_blank">
        <i class="large instagram icon" title="instagram"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.linkedin.com/in/SLTaurus" target="_blank">
        <i class="large linkedin icon" title="linkedin"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://github.com/SLTaurus" target="_blank">
        <i class="large github icon" title="github"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://www.stackoverflow.com/users/SLTaurus" target="_blank">
        <i class="large stack overflow icon" title="stackoverflow"></i>
      </a>
    </div>
  

  
    <div class="item">
      <a href="https://codepen.io/SLTaurus" target="_blank">
        <i class="large codepen icon" title="codepen"></i>
      </a>
    </div>
  
</nav>

      </div>
    </article>
  </section>

  <section class="sixteen wide mobile eight wide tablet four wide computer column dream-column">
    
  </section>

  
  
    <section class="sixteen wide mobile eight wide tablet eight wide computer column dream-column">
      <footer class="ui segment">
        <div id="disqus_thread"></div>
        <script>
          


          var disqus_config = function () {
            this.page.url = 'https:\/\/sltaurusblog.gitee.io\/2019\/08\/javascript%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E7%AC%AC6%E7%89%88%E7%AC%94%E8%AE%B0%E4%B8%8A\/about';  
            this.page.identifier = '/about'; 
          };

          (function() { 
            var d = document, s = d.createElement('script');
            s.src = 'https://' + '...' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </footer>
    </section>
  

</div>

        </section>
      </div>
    </div>

    <script src="https://sltaurusblog.gitee.io/js/jquery.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/semantic.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/imagesloaded.pkgd.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/masonry.pkgd.min.js"></script>
<script src="https://sltaurusblog.gitee.io/js/nav.js"></script>
<script src="https://sltaurusblog.gitee.io/js/header.js"></script>
<script src="https://sltaurusblog.gitee.io/js/main.js"></script>
<script src="https://sltaurusblog.gitee.io/js/theme.js"></script>
<script src="https://sltaurusblog.gitee.io/js/html2canvas.min.js"></script>

  
    <script src="https://sltaurusblog.gitee.io/js/prism.js"></script>
  


  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', '...', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>




  </body>
</html>
